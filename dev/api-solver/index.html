<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solver · PhoXonic.jl</title><meta name="title" content="Solver · PhoXonic.jl"/><meta property="og:title" content="Solver · PhoXonic.jl"/><meta property="twitter:title" content="Solver · PhoXonic.jl"/><meta name="description" content="Documentation for PhoXonic.jl."/><meta property="og:description" content="Documentation for PhoXonic.jl."/><meta property="twitter:description" content="Documentation for PhoXonic.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PhoXonic.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../workflow/">Workflow (2D)</a></li><li><a class="tocitem" href="../workflow_1d/">1D Calculations</a></li><li><a class="tocitem" href="../workflow_3d/">3D Calculations</a></li><li><a class="tocitem" href="../solver/">Solver Methods</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li><a class="tocitem" href="../greens_function/">DOS / LDOS</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../matrixfree/">Matrix-Free Methods</a></li><li><a class="tocitem" href="../elastic_void/">Elastic Void (Tanaka Limit)</a></li><li><a class="tocitem" href="../tmm/">Transfer Matrix Method (1D)</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Core</a></li><li class="is-active"><a class="tocitem" href>Solver</a><ul class="internal"><li><a class="tocitem" href="#Wave-Types"><span>Wave Types</span></a></li><li><a class="tocitem" href="#Solver"><span>Solver</span></a></li><li><a class="tocitem" href="#Solver-Method-Types"><span>Solver Method Types</span></a></li><li><a class="tocitem" href="#Band-Structure"><span>Band Structure</span></a></li><li><a class="tocitem" href="#K-path"><span>K-path</span></a></li></ul></li><li><a class="tocitem" href="../api-advanced/">Advanced</a></li><li><a class="tocitem" href="../api-plotting/">Plotting</a></li><li><a class="tocitem" href="../api-io/">I/O</a></li></ul></li><li><a class="tocitem" href="../dependencies/">Dependencies</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Solver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solver</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solver-API"><a class="docs-heading-anchor" href="#Solver-API">Solver API</a><a id="Solver-API-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-API" title="Permalink"></a></h1><h2 id="Wave-Types"><a class="docs-heading-anchor" href="#Wave-Types">Wave Types</a><a id="Wave-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Wave-Types" title="Permalink"></a></h2><h3 id="Abstract-Types"><a class="docs-heading-anchor" href="#Abstract-Types">Abstract Types</a><a id="Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PhoXonic.WaveType"><a class="docstring-binding" href="#PhoXonic.WaveType"><code>PhoXonic.WaveType</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for all wave types.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.PhotonicWave"><a class="docstring-binding" href="#PhoXonic.PhotonicWave"><code>PhoXonic.PhotonicWave</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for photonic (electromagnetic) waves.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.PhononicWave"><a class="docstring-binding" href="#PhoXonic.PhononicWave"><code>PhoXonic.PhononicWave</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for phononic (elastic) waves.</p></div></section></details></article><h3 id="2D-Wave-Types"><a class="docs-heading-anchor" href="#2D-Wave-Types">2D Wave Types</a><a id="2D-Wave-Types-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Wave-Types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PhoXonic.TEWave"><a class="docstring-binding" href="#PhoXonic.TEWave"><code>PhoXonic.TEWave</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TEWave &lt;: PhotonicWave</code></pre><p>Transverse Electric polarization (H_z mode) for 2D photonic crystals.</p><p>Electric field is in the xy-plane, magnetic field H is along z. The eigenvalue equation is: ∇×(ε⁻¹∇×H<em>z) = (ω/c)² μ H</em>z</p><p><strong>Field Components</strong></p><ul><li>Solved: H_z (scalar)</li><li>Derived: E<em>x, E</em>y from H_z</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">solver = Solver(TEWave(), geo, (64, 64))
solver = Solver(TEWave(), geo, (64, 64), KrylovKitMethod())
solver = Solver(TEWave(), geo, (64, 64), LOBPCGMethod())</code></pre><p>See also: <a href="#PhoXonic.TMWave"><code>TMWave</code></a>, <a href="#PhoXonic.FullVectorEM"><code>FullVectorEM</code></a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.TMWave"><a class="docstring-binding" href="#PhoXonic.TMWave"><code>PhoXonic.TMWave</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TMWave &lt;: PhotonicWave</code></pre><p>Transverse Magnetic polarization (E_z mode) for 2D photonic crystals.</p><p>Magnetic field is in the xy-plane, electric field E is along z. The eigenvalue equation is: ∇×(μ⁻¹∇×E<em>z) = (ω/c)² ε E</em>z</p><p><strong>Field Components</strong></p><ul><li>Solved: E_z (scalar)</li><li>Derived: H<em>x, H</em>y from E_z</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">solver = Solver(TMWave(), geo, (64, 64))
solver = Solver(TMWave(), geo, (64, 64), KrylovKitMethod())
solver = Solver(TMWave(), geo, (64, 64), LOBPCGMethod())</code></pre><p>See also: <a href="#PhoXonic.TEWave"><code>TEWave</code></a>, <a href="#PhoXonic.FullVectorEM"><code>FullVectorEM</code></a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.SHWave"><a class="docstring-binding" href="#PhoXonic.SHWave"><code>PhoXonic.SHWave</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SHWave &lt;: PhononicWave</code></pre><p>Shear Horizontal (out-of-plane, anti-plane) elastic wave for 2D phononic crystals.</p><p>Displacement u<em>z is perpendicular to the xy-plane. The eigenvalue equation is: ∇·(C₄₄∇u</em>z) = -ρω² u_z</p><p><strong>Field Components</strong></p><ul><li>Solved: u_z (scalar)</li><li>Decoupled from in-plane (P-SV) modes</li></ul><p><strong>Notes</strong></p><ul><li>Eigenvalues ω² can be O(10¹⁰) for typical materials</li><li>KrylovKitMethod uses automatic scaling for numerical stability</li><li>LOBPCGMethod works without explicit scaling</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">steel = IsotropicElastic(ρ=7800.0, λ=115e9, μ=82e9)
epoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)
geo = Geometry(lat, epoxy, [(Circle([0,0], 0.3), steel)])

solver = Solver(SHWave(), geo, (64, 64))
solver = Solver(SHWave(), geo, (64, 64), KrylovKitMethod())
solver = Solver(SHWave(), geo, (64, 64), LOBPCGMethod())</code></pre><p>See also: <a href="#PhoXonic.PSVWave"><code>PSVWave</code></a>, <a href="#PhoXonic.FullElastic"><code>FullElastic</code></a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.PSVWave"><a class="docstring-binding" href="#PhoXonic.PSVWave"><code>PhoXonic.PSVWave</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PSVWave &lt;: PhononicWave</code></pre><p>P-SV (in-plane) elastic wave for 2D phononic crystals.</p><p>Displacement (u<em>x, u</em>y) is in the xy-plane, coupling P (longitudinal) and SV (shear vertical) polarizations.</p><p><strong>Field Components</strong></p><ul><li>Solved: u<em>x, u</em>y (2 components)</li><li>Produces 2 bands per k-point (quasi-P and quasi-SV)</li></ul><p><strong>Notes</strong></p><ul><li>Eigenvalues ω² can be O(10¹⁰) for typical materials</li><li>KrylovKitMethod uses automatic scaling for numerical stability</li><li>LOBPCGMethod works without explicit scaling</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">steel = IsotropicElastic(ρ=7800.0, λ=115e9, μ=82e9)
epoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)
geo = Geometry(lat, epoxy, [(Circle([0,0], 0.3), steel)])

solver = Solver(PSVWave(), geo, (64, 64))
solver = Solver(PSVWave(), geo, (64, 64), KrylovKitMethod())
solver = Solver(PSVWave(), geo, (64, 64), LOBPCGMethod())</code></pre><p>See also: <a href="#PhoXonic.SHWave"><code>SHWave</code></a>, <a href="#PhoXonic.FullElastic"><code>FullElastic</code></a></p></div></section></details></article><h3 id="1D-Wave-Types"><a class="docs-heading-anchor" href="#1D-Wave-Types">1D Wave Types</a><a id="1D-Wave-Types-1"></a><a class="docs-heading-anchor-permalink" href="#1D-Wave-Types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PhoXonic.Photonic1D"><a class="docstring-binding" href="#PhoXonic.Photonic1D"><code>PhoXonic.Photonic1D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Photonic1D &lt;: PhotonicWave</code></pre><p>Scalar electromagnetic wave for 1D photonic structures (Bragg reflectors, etc.).</p><p>The eigenvalue equation is: -d/dx(ε⁻¹ d/dx E) = (ω/c)² E</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">lat = lattice_1d(1.0)
geo = Geometry(lat, mat1, [(Segment(0.0, 0.5), mat2)])
solver = Solver(Photonic1D(), geo, 128; cutoff=20)
solver = Solver(Photonic1D(), geo, 128, KrylovKitMethod(); cutoff=20)
solver = Solver(Photonic1D(), geo, 128, LOBPCGMethod(); cutoff=20)</code></pre><p>See also: <a href="#PhoXonic.TEWave"><code>TEWave</code></a>, <a href="#PhoXonic.TMWave"><code>TMWave</code></a>, <a href="#PhoXonic.Longitudinal1D"><code>Longitudinal1D</code></a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.Longitudinal1D"><a class="docstring-binding" href="#PhoXonic.Longitudinal1D"><code>PhoXonic.Longitudinal1D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Longitudinal1D &lt;: PhononicWave</code></pre><p>Longitudinal elastic wave for 1D phononic structures (superlattices, etc.).</p><p>The eigenvalue equation is: d/dx(C₁₁ du/dx) = -ρω² u</p><p><strong>Notes</strong></p><ul><li>Eigenvalues ω² can be O(10¹⁰) for typical materials</li><li>KrylovKitMethod uses automatic scaling for numerical stability</li><li>LOBPCGMethod works without explicit scaling</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">lat = lattice_1d(1.0)
steel = IsotropicElastic(ρ=7800.0, λ=115e9, μ=82e9)
epoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)
geo = Geometry(lat, epoxy, [(Segment(0.0, 0.5), steel)])

solver = Solver(Longitudinal1D(), geo, 128; cutoff=20)
solver = Solver(Longitudinal1D(), geo, 128, KrylovKitMethod(); cutoff=20)
solver = Solver(Longitudinal1D(), geo, 128, LOBPCGMethod(); cutoff=20)</code></pre><p>See also: <a href="#PhoXonic.SHWave"><code>SHWave</code></a>, <a href="#PhoXonic.PSVWave"><code>PSVWave</code></a>, <a href="#PhoXonic.Photonic1D"><code>Photonic1D</code></a></p></div></section></details></article><h3 id="3D-Wave-Types"><a class="docs-heading-anchor" href="#3D-Wave-Types">3D Wave Types</a><a id="3D-Wave-Types-1"></a><a class="docs-heading-anchor-permalink" href="#3D-Wave-Types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PhoXonic.TransverseEM"><a class="docstring-binding" href="#PhoXonic.TransverseEM"><code>PhoXonic.TransverseEM</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TransverseEM &lt;: PhotonicWave</code></pre><p>Transverse electromagnetic wave for 3D photonic crystals (recommended).</p><p>Uses H-field formulation with transverse projection, ensuring ∇·H = 0. This is the MPB-compatible formulation for accurate band structure calculations.</p><p><strong>Field Components</strong></p><ul><li>Basis: 2 polarization vectors (e₁, e₂) perpendicular to k+G</li><li>Matrix size: 2N×2N (vs 3N×3N for FullVectorEM)</li><li>No spurious longitudinal modes</li></ul><p><strong>Mathematical Formulation</strong></p><p>For each plane wave G, the H field is expanded as:     H_G = h₁(G) e₁(G) + h₂(G) e₂(G) where e₁, e₂ are orthonormal vectors perpendicular to k+G.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">lat = fcc_lattice(1.0)
geo = Geometry(lat, air, [(Sphere([0,0,0], 0.25), dielectric)])

# Recommended for band structure calculations
solver = Solver(TransverseEM(), geo, (16, 16, 16); cutoff=5)
bands = compute_bands(solver, kpath; bands=1:10)</code></pre><p>See also: <a href="#PhoXonic.FullVectorEM"><code>FullVectorEM</code></a>, <a href="#PhoXonic.TEWave"><code>TEWave</code></a>, <a href="#PhoXonic.TMWave"><code>TMWave</code></a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.FullVectorEM"><a class="docstring-binding" href="#PhoXonic.FullVectorEM"><code>PhoXonic.FullVectorEM</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FullVectorEM &lt;: PhotonicWave</code></pre><p>Full vector electromagnetic wave for 3D photonic crystals.</p><p>Uses H-field formulation: ∇×(ε⁻¹∇×H) = (ω/c)² μ H</p><p><strong>Field Components</strong></p><ul><li>Solved: H<em>x, H</em>y, H_z (3 components)</li><li>Physical modes: 2 transverse modes per k-point</li></ul><p><strong>Notes</strong></p><ul><li>Produces spurious longitudinal modes at ω ≈ 0 (unphysical)</li><li>Use <code>shift</code> parameter with iterative solvers to skip spurious modes</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">lat = cubic_lattice(1.0)
geo = Geometry(lat, air, [(Sphere([0,0,0], 0.3), rod)])
solver = Solver(FullVectorEM(), geo, (16, 16, 16); cutoff=3)

# Iterative solvers require shift to skip spurious modes
solver = Solver(FullVectorEM(), geo, (16, 16, 16), KrylovKitMethod(shift=0.01); cutoff=3)
solver = Solver(FullVectorEM(), geo, (16, 16, 16), LOBPCGMethod(shift=0.01); cutoff=3)</code></pre><p>See also: <a href="#PhoXonic.TEWave"><code>TEWave</code></a>, <a href="#PhoXonic.TMWave"><code>TMWave</code></a>, <a href="#PhoXonic.FullElastic"><code>FullElastic</code></a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.FullElastic"><a class="docstring-binding" href="#PhoXonic.FullElastic"><code>PhoXonic.FullElastic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FullElastic &lt;: PhononicWave</code></pre><p>Full elastic wave for 3D phononic crystals.</p><p>Solves the elastodynamic equation: ∇·σ = -ρω²u where σ = C:ε</p><p><strong>Field Components</strong></p><ul><li>Solved: u<em>x, u</em>y, u_z (3 components)</li><li>Produces 3 bands per k-point (1 quasi-P + 2 quasi-S)</li></ul><p><strong>Notes</strong></p><ul><li>Eigenvalues ω² can be O(10¹⁰) for typical materials</li><li>Use <code>shift</code> parameter with iterative solvers for 3D</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">lat = cubic_lattice(1.0)
steel = IsotropicElastic(ρ=7800.0, λ=115e9, μ=82e9)
epoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)
geo = Geometry(lat, epoxy, [(Sphere([0,0,0], 0.3), steel)])

solver = Solver(FullElastic(), geo, (16, 16, 16); cutoff=3)

# Iterative solvers may require shift for 3D
solver = Solver(FullElastic(), geo, (16, 16, 16), KrylovKitMethod(shift=0.01); cutoff=3)
solver = Solver(FullElastic(), geo, (16, 16, 16), LOBPCGMethod(shift=0.01); cutoff=3)</code></pre><p>See also: <a href="#PhoXonic.SHWave"><code>SHWave</code></a>, <a href="#PhoXonic.PSVWave"><code>PSVWave</code></a>, <a href="#PhoXonic.FullVectorEM"><code>FullVectorEM</code></a></p></div></section></details></article><h2 id="Solver"><a class="docs-heading-anchor" href="#Solver">Solver</a><a id="Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Solver" title="Permalink"></a></h2><h3 id="Solver-Types"><a class="docs-heading-anchor" href="#Solver-Types">Solver Types</a><a id="Solver-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-Types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PhoXonic.AbstractSolver"><a class="docstring-binding" href="#PhoXonic.AbstractSolver"><code>PhoXonic.AbstractSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractSolver</code></pre><p>Abstract base type for all solvers in PhoXonic.jl.</p><p>Subtypes:</p><ul><li><code>Solver</code>: Plane wave expansion (PWE) solver</li></ul><p>This abstract type allows for future extensions (e.g., GME solver).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.Solver"><a class="docstring-binding" href="#PhoXonic.Solver"><code>PhoXonic.Solver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Solver{D&lt;:Dimension, W&lt;:WaveType, M&lt;:SolverMethod} &lt;: AbstractSolver</code></pre><p>Solver for computing band structures of photonic/phononic crystals using the plane wave expansion (PWE) method.</p><p><strong>Fields</strong></p><ul><li><code>wave</code>: Wave type (TE, TM, SH, etc.)</li><li><code>geometry</code>: Crystal geometry</li><li><code>basis</code>: Plane wave basis</li><li><code>resolution</code>: Grid resolution for discretization</li><li><code>material_arrays</code>: Pre-computed material arrays on the grid</li><li><code>method</code>: Solver method (DenseMethod(), BasicRSCG(), etc.)</li></ul></div></section></details></article><h3 id="High-level-API"><a class="docs-heading-anchor" href="#High-level-API">High-level API</a><a id="High-level-API-1"></a><a class="docs-heading-anchor-permalink" href="#High-level-API" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PhoXonic.solve"><a class="docstring-binding" href="#PhoXonic.solve"><code>PhoXonic.solve</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve(solver::Solver, k; bands=1:10)</code></pre><p>Solve the eigenvalue problem at wave vector k.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: The solver</li><li><code>k</code>: Wave vector (in units of reciprocal lattice vectors or absolute)</li><li><code>bands</code>: Which bands to return (default: 1:10)</li></ul><p><strong>Returns</strong></p><ul><li><code>frequencies</code>: Eigenfrequencies (sorted, positive)</li><li><code>modes</code>: Corresponding eigenvectors</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.solve_at_k"><a class="docstring-binding" href="#PhoXonic.solve_at_k"><code>PhoXonic.solve_at_k</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve_at_k(solver, k, method; bands=1:10, X0=nothing, P=nothing)</code></pre><p>Solve eigenvalue problem at a single k-point with explicit control over method, initial vectors, and preconditioner. Returns only frequencies.</p><p>For eigenvectors, use <a href="#PhoXonic.solve_at_k_with_vectors"><code>solve_at_k_with_vectors</code></a> instead.</p><p><strong>Arguments</strong></p><ul><li><code>solver::Solver</code>: Solver instance</li><li><code>k</code>: Wave vector (2D: Vector{Float64}, 1D: Float64)</li><li><code>method::SolverMethod</code>: Solver method (DenseMethod, LOBPCGMethod, etc.)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>bands</code>: Range of bands to compute (default: 1:10)</li><li><code>X0</code>: Initial guess for eigenvectors (default: nothing = auto)<ul><li>Size: <code>dim × nev</code> where <code>dim = matrix_dimension(solver)</code> and <code>nev = maximum(bands)</code></li><li>Type: <code>Matrix{ComplexF64}</code></li><li>If <code>nothing</code>, random orthonormal vectors are used</li></ul></li><li><code>P</code>: Preconditioner (default: nothing = use method&#39;s preconditioner setting)<ul><li>Must implement <code>ldiv!(y, P, x)</code></li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Frequencies for the requested bands</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">solver = Solver(PSVWave(), geo, (64, 64); cutoff=20)
dim = matrix_dimension(solver)  # 2514 for cutoff=20

# Frequencies only
freqs = solve_at_k(solver, k, LOBPCGMethod(); bands=1:20)

# With eigenvectors - use solve_at_k_with_vectors
freqs, vecs = solve_at_k_with_vectors(solver, k, DenseMethod(); bands=1:20)

# Custom preconditioner
using LinearAlgebra
LHS, _ = build_matrices(solver, k)
P = Diagonal(1.0 ./ diag(LHS))
freqs = solve_at_k(solver, k, LOBPCGMethod(); bands=1:20, P=P)</code></pre><p>See also: <a href="#PhoXonic.solve_at_k_with_vectors"><code>solve_at_k_with_vectors</code></a>, <a href="#PhoXonic.solve"><code>solve</code></a>, <a href="#PhoXonic.matrix_dimension"><code>matrix_dimension</code></a></p></div></section><section><div><pre><code class="language-julia hljs">solve_at_k(solver, k, method; kwargs...)</code></pre><p>Solve eigenvalue problem at a single k-point.</p><p>See concrete method signatures for detailed documentation and keyword arguments.</p></div></section></details></article><h3 id="Mid-level-API"><a class="docs-heading-anchor" href="#Mid-level-API">Mid-level API</a><a id="Mid-level-API-1"></a><a class="docs-heading-anchor-permalink" href="#Mid-level-API" title="Permalink"></a></h3><p>For custom algorithms and advanced analysis:</p><article><details class="docstring" open="true"><summary id="PhoXonic.solve_at_k_with_vectors"><a class="docstring-binding" href="#PhoXonic.solve_at_k_with_vectors"><code>PhoXonic.solve_at_k_with_vectors</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve_at_k_with_vectors(solver, k, method; bands=1:10, X0=nothing, P=nothing)</code></pre><p>Solve eigenvalue problem at a single k-point and return both frequencies and eigenvectors.</p><p>This function always returns eigenvectors, unlike <code>solve_at_k</code> which returns only frequencies by default. Use this when you need the eigenvectors for further analysis (e.g., computing overlaps, mode profiles, or topological invariants).</p><p><strong>Arguments</strong></p><ul><li><code>solver::AbstractSolver</code>: The solver object</li><li><code>k</code>: Wave vector (Real for 1D, AbstractVector for 2D/3D)</li><li><code>method::SolverMethod</code>: Solver method (DenseMethod(), KrylovKitMethod(), LOBPCGMethod())</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>bands</code>: Range of bands to compute (default: 1:10)</li><li><code>X0</code>: Initial guess for eigenvectors (for LOBPCG, optional)</li><li><code>P</code>: Preconditioner (for LOBPCG, optional)</li></ul><p><strong>Returns</strong></p><ul><li><code>(frequencies, eigenvectors)</code>: Tuple of frequencies (Vector{Float64}) and eigenvectors (Matrix{ComplexF64})</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">ω, vecs = solve_at_k_with_vectors(solver, [0.1, 0.2], DenseMethod(); bands=1:4)
W = get_weight_matrix(solver)
overlap = vecs&#39; * W * vecs  # Should be ≈ I (orthonormal)</code></pre><p>See also: <a href="#PhoXonic.solve_at_k"><code>solve_at_k</code></a>, <a href="#PhoXonic.get_weight_matrix"><code>get_weight_matrix</code></a>, <a href="#PhoXonic.build_matrices"><code>build_matrices</code></a></p></div></section><section><div><pre><code class="language-julia hljs">solve_at_k_with_vectors(solver, k, method; kwargs...)</code></pre><p>Solve eigenvalue problem and return both frequencies and eigenvectors.</p><p>See concrete method signatures for detailed documentation and keyword arguments.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.build_matrices"><a class="docstring-binding" href="#PhoXonic.build_matrices"><code>PhoXonic.build_matrices</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">build_matrices(solver::Solver, k)</code></pre><p>Build the eigenvalue problem matrices LHS * ψ = ω² * RHS * ψ for wave vector k.</p></div></section><section><div><pre><code class="language-julia hljs">build_matrices(solver::Solver{Dim3, FullVectorEM}, k)</code></pre><p>Build 3N×3N matrices for 3D photonic crystal (H-field formulation).</p><p>Formulation: curl × ε⁻¹ × curl H = (ω²/c²) μ H</p><p>Storage order: [H<em>x; H</em>y; H_z] (component-order for FFT efficiency)</p></div></section><section><div><pre><code class="language-julia hljs">build_matrices(solver::Solver{Dim3, TransverseEM}, k)</code></pre><p>Build 2N×2N matrices for 3D photonic crystal with transverse projection.</p><p>This is the MPB-compatible formulation that enforces ∇·H = 0 by projecting the 3N×3N FullVectorEM matrices onto the 2N-dimensional transverse subspace.</p><p><strong>Algorithm</strong></p><ol><li>Build 3N×3N matrices (LHS<em>3N, RHS</em>3N) as in FullVectorEM</li><li>Construct polarization basis P (3N × 2N) where each column is a transverse polarization vector perpendicular to k+G</li><li>Project: LHS = P&#39; * LHS<em>3N * P, RHS = P&#39; * RHS</em>3N * P</li></ol><p><strong>Advantages over FullVectorEM</strong></p><ul><li>Matrix size: 2N×2N (vs 3N×3N) → ~2.25× faster solve</li><li>No spurious longitudinal modes (ω ≈ 0)</li><li>Correct physical results matching MPB</li></ul></div></section><section><div><pre><code class="language-julia hljs">build_matrices(solver::Solver{Dim3, FullElastic}, k)</code></pre><p>Build 3N×3N matrices for 3D phononic crystal.</p><p>Formulation: -∇·(C:∇u) = ω² ρ u</p><p>Storage order: [u<em>x; u</em>y; u_z] (component-order)</p></div></section><section><div><pre><code class="language-julia hljs">build_matrices(solver, k)</code></pre><p>Build the LHS and RHS matrices for the generalized eigenvalue problem.</p><p>See concrete method signatures for detailed documentation.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.get_weight_matrix"><a class="docstring-binding" href="#PhoXonic.get_weight_matrix"><code>PhoXonic.get_weight_matrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_weight_matrix(solver::Solver{Dim3, TransverseEM})</code></pre><p>Not directly available for TransverseEM due to k-dependency.</p><p>The weight matrix for TransverseEM is the projected μ matrix: W = P&#39; * μ_3N * P, where P is the polarization basis that depends on k. Since this varies with each k-point, a single k-independent weight matrix cannot be provided.</p><p><strong>Alternative</strong></p><p>Use the RHS matrix returned by <code>build_matrices(solver, k)</code> instead:</p><pre><code class="language-julia hljs">LHS, RHS = build_matrices(solver, k)
# RHS is the 2N×2N projected weight matrix for this k-point</code></pre><p><strong>See also</strong></p><ul><li><a href="#PhoXonic.build_matrices"><code>build_matrices</code></a>: Returns both LHS and RHS (weight) matrices</li><li><a href="#PhoXonic.solve_at_k_with_vectors"><code>solve_at_k_with_vectors</code></a>: Returns eigenvectors in the 2N transverse basis</li></ul></div></section><section><div><pre><code class="language-julia hljs">get_weight_matrix(solver)</code></pre><p>Return the weight matrix W for computing inner products of eigenvectors.</p><p>The weight matrix satisfies: <code>vecs&#39; * W * vecs ≈ I</code> for orthonormal eigenvectors. This is the RHS matrix of the generalized eigenvalue problem, which defines the inner product in the function space.</p><p>See concrete method signatures for detailed documentation.</p></div></section></details></article><h3 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PhoXonic.matrix_dimension"><a class="docstring-binding" href="#PhoXonic.matrix_dimension"><code>PhoXonic.matrix_dimension</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">matrix_dimension(solver::Solver) -&gt; Int</code></pre><p>Return the dimension of the eigenvalue problem matrix.</p><p>This is the size of the matrices A and B in the generalized eigenvalue problem <code>A x = λ B x</code>. Use this to determine the size of initial vectors for iterative solvers like LOBPCG.</p><p><strong>Returns</strong></p><ul><li><code>num_pw</code> for scalar waves (TE, TM, SH, 1D waves)</li><li><code>2 * num_pw</code> for 2D vector waves (P-SV)</li><li><code>3 * num_pw</code> for 3D vector waves (FullVectorEM, FullElastic)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">solver = Solver(PSVWave(), geo, (64, 64); cutoff=20)
dim = matrix_dimension(solver)  # 2 * num_pw

# Create initial vectors for LOBPCG
X0 = randn(ComplexF64, dim, 20)
X0, _ = qr(X0)
X0 = Matrix(X0)</code></pre></div></section><section><div><pre><code class="language-julia hljs">matrix_dimension(solver)</code></pre><p>Return the matrix dimension for the eigenvalue problem.</p><p>See concrete method signatures for detailed documentation.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.group_velocity"><a class="docstring-binding" href="#PhoXonic.group_velocity"><code>PhoXonic.group_velocity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">group_velocity(solver::Solver, k; bands=1:10, δk=1e-5)</code></pre><p>Compute group velocity v_g = ∂ω/∂k at wave vector k.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: The solver</li><li><code>k</code>: Wave vector</li><li><code>bands</code>: Which bands to compute (default: 1:10)</li><li><code>δk</code>: Finite difference step size (default: 1e-5)</li></ul><p><strong>Returns</strong></p><ul><li><code>v_g</code>: Group velocity vectors for each band<ul><li>2D: Vector of SVector{2} (v<em>gx, v</em>gy)</li><li>1D: Vector of Float64</li></ul></li></ul></div></section></details></article><h2 id="Solver-Method-Types"><a class="docs-heading-anchor" href="#Solver-Method-Types">Solver Method Types</a><a id="Solver-Method-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-Method-Types" title="Permalink"></a></h2><h3 id="Abstract-Types-2"><a class="docs-heading-anchor" href="#Abstract-Types-2">Abstract Types</a><a class="docs-heading-anchor-permalink" href="#Abstract-Types-2" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PhoXonic.SolverMethod"><a class="docstring-binding" href="#PhoXonic.SolverMethod"><code>PhoXonic.SolverMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SolverMethod</code></pre><p>Abstract type for solver methods.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.IterativeMethod"><a class="docstring-binding" href="#PhoXonic.IterativeMethod"><code>PhoXonic.IterativeMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IterativeMethod &lt;: SolverMethod</code></pre><p>Abstract type for iterative solver methods.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.RSCGMethod"><a class="docstring-binding" href="#PhoXonic.RSCGMethod"><code>PhoXonic.RSCGMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RSCGMethod &lt;: IterativeMethod</code></pre><p>Abstract type for Reduced Shifted Conjugate Gradient methods. Used for Green&#39;s function calculations.</p></div></section></details></article><h3 id="Concrete-Methods"><a class="docs-heading-anchor" href="#Concrete-Methods">Concrete Methods</a><a id="Concrete-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-Methods" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PhoXonic.DenseMethod"><a class="docstring-binding" href="#PhoXonic.DenseMethod"><code>PhoXonic.DenseMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DenseMethod &lt;: SolverMethod</code></pre><p>Dense matrix eigenvalue solver using LAPACK&#39;s <code>eigen</code> function.</p><p>This is the default method, suitable for small to medium-sized systems. It builds the full N×N matrices and computes all eigenvalues/eigenvectors.</p><p><strong>Fields</strong></p><ul><li><code>shift::Float64</code>: Minimum eigenvalue cutoff (default: 0.0)<ul><li>Eigenvalues with ω² &lt; shift are filtered out after solving</li><li>Use <code>shift &gt; 0</code> for 3D FullVectorEM to skip spurious longitudinal modes (λ ≈ 0)</li><li>Recommended: <code>shift = 0.01</code> for 3D photonic crystals</li><li>Note: Unlike iterative methods, this is post-hoc filtering, not shift-and-invert</li></ul></li></ul><p><strong>Complexity</strong></p><ul><li>Memory: O(N²)</li><li>Time: O(N³)</li></ul><p>where N = num<em>plane</em>waves × ncomponents(wave)</p><p><strong>Recommended For</strong></p><ul><li>1D systems (any resolution)</li><li>2D systems with N &lt; ~1000</li><li>Development and debugging (exact results)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Default (implicit)
solver = Solver(TEWave(), geo, (64, 64))

# Explicit
solver = Solver(TEWave(), geo, (64, 64), DenseMethod())

# 3D with shift to skip spurious modes
solver = Solver(FullVectorEM(), geo, (12, 12, 12), DenseMethod(shift=0.01))</code></pre><p>See also: <a href="../solver/#KrylovKitMethod"><code>KrylovKitMethod</code></a>, <a href="../solver/#LOBPCGMethod"><code>LOBPCGMethod</code></a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.BasicRSCG"><a class="docstring-binding" href="#PhoXonic.BasicRSCG"><code>PhoXonic.BasicRSCG</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BasicRSCG &lt;: RSCGMethod</code></pre><p>Basic RSCG method for Green&#39;s function computation. Suitable for DOS/LDOS calculations in large systems.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.KrylovKitMethod"><a class="docstring-binding" href="#PhoXonic.KrylovKitMethod"><code>PhoXonic.KrylovKitMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KrylovKitMethod &lt;: IterativeMethod</code></pre><p>Iterative eigenvalue solver using KrylovKit.jl. Suitable for large systems where dense matrix storage is impractical.</p><p>Uses shift-and-invert spectral transformation when <code>shift &gt; 0</code>:</p><ul><li>Original problem: <code>A x = λ B x</code></li><li>Transformed: <code>(A - σB)⁻¹ B x = μ x</code> where <code>μ = 1/(λ - σ)</code></li></ul><p>This is particularly useful for 3D calculations where the H-field formulation produces N spurious longitudinal modes with λ ≈ 0. Setting <code>shift &gt; 0</code> (e.g., 0.01) effectively filters out these unphysical modes and focuses on the transverse (physical) modes.</p><p><strong>Fields</strong></p><ul><li><code>tol::Float64</code>: Convergence tolerance (default: 1e-8)</li><li><code>maxiter::Int</code>: Maximum iterations (default: 300)</li><li><code>krylovdim::Int</code>: Krylov subspace dimension (default: 30)</li><li><code>verbosity::Int</code>: Output verbosity level (0=silent, 1=warn, 2=info)</li><li><code>shift::Float64</code>: Spectral shift σ for shift-and-invert (default: 0.0)<ul><li><code>shift = 0</code>: Standard generalized eigenvalue problem (no transformation)</li><li><code>shift &gt; 0</code>: Shift-and-invert, finds eigenvalues closest to σ</li><li>Recommended: <code>shift = 0.01</code> for 3D photonic crystals to skip longitudinal modes</li></ul></li><li><code>matrix_free::Bool</code>: Use matrix-free operators for shift-and-invert (default: false)<ul><li><code>false</code>: Build dense matrices (faster for N &lt; 2000)</li><li><code>true</code>: Use O(N) memory with iterative inner solver (for large 3D problems)</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># 2D calculation (no shift needed)
method = KrylovKitMethod()

# 3D calculation (use shift to skip longitudinal modes)
method = KrylovKitMethod(shift=0.01)

# Target specific frequency range
method = KrylovKitMethod(shift=1.5)  # Find modes near ω² = 1.5</code></pre><p>See also: <a href="../solver/#DenseMethod"><code>DenseMethod</code></a>, <a href="#Solver"><code>Solver</code></a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.LOBPCGMethod"><a class="docstring-binding" href="#PhoXonic.LOBPCGMethod"><code>PhoXonic.LOBPCGMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LOBPCGMethod &lt;: IterativeMethod</code></pre><p>Locally Optimal Block Preconditioned Conjugate Gradient method. Based on Knyazev (2001), SIAM J. Sci. Comput. Vol.23, No.2, pp.517-541.</p><p>Solves the symmetric generalized eigenvalue problem <code>A x = λ B x</code> where both A and B are Hermitian and B is positive definite. This method is particularly effective for:</p><ul><li>Large-scale band structure calculations with <code>compute_bands</code></li><li>Phononic crystal calculations (steel/epoxy, silicon/air, etc.)</li></ul><p>With warm start enabled (default), LOBPCG reuses eigenvectors from previous k-points as initial guesses, achieving significant speedup while maintaining accuracy. The first k-point uses Dense (if first_dense=true) to provide accurate initial eigenvectors.</p><p><strong>Fields</strong></p><ul><li><code>tol::Float64</code>: Convergence tolerance (default: 1e-3)</li><li><code>maxiter::Int</code>: Maximum iterations (default: 100)</li><li><code>shift::Float64</code>: Spectral shift for shift-and-invert transformation (default: 0.0)</li><li><code>warm_start::Bool</code>: Use previous eigenvectors as initial guess (default: true)</li><li><code>scale::Bool</code>: Scale matrix A by max|A| (default: false, scaling can hurt phononic problems)</li><li><code>first_dense::Bool</code>: Solve first k-point with Dense for accurate warm start (default: true)</li><li><code>preconditioner</code>: Preconditioner type (default: :none)</li></ul><p><strong>Notes</strong></p><ul><li>Requires symmetric/Hermitian matrices A and B</li><li>B must be positive definite</li><li>Works directly with dense matrices (no matrix-free support yet)</li><li>Block method: computes multiple eigenvalues simultaneously</li><li>For phononic problems, leave scale=false and preconditioner=:none (defaults)</li><li>When shift &gt; 0, uses shift-and-invert to skip eigenvalues near zero (useful for 3D H-field formulation where spurious modes exist at λ ≈ 0)</li><li><strong>Note</strong>: With shift &gt; 0, the method falls back to dense <code>eigen</code> solver internally because the shifted matrix (A - σB) is not positive definite as required by LOBPCG.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Default with warm start (recommended for band structure)
solver = Solver(PSVWave(), geo, (64, 64), LOBPCGMethod(); cutoff=20)

# For 3D FullVectorEM (skip spurious modes at λ ≈ 0)
method = LOBPCGMethod(shift=0.01)</code></pre><p>See also: <a href="../solver/#KrylovKitMethod"><code>KrylovKitMethod</code></a>, <a href="../solver/#DenseMethod"><code>DenseMethod</code></a>, <a href="#PhoXonic.matrix_dimension"><code>matrix_dimension</code></a></p></div></section></details></article><h2 id="Band-Structure"><a class="docs-heading-anchor" href="#Band-Structure">Band Structure</a><a id="Band-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Band-Structure" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PhoXonic.BandStructure"><a class="docstring-binding" href="#PhoXonic.BandStructure"><code>PhoXonic.BandStructure</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BandStructure</code></pre><p>Results of a band structure calculation.</p><p><strong>Fields</strong></p><ul><li><code>kpoints</code>: K-points used (as vector of SVectors)</li><li><code>distances</code>: Cumulative distances along the path</li><li><code>frequencies</code>: Matrix of frequencies (nk × nbands)</li><li><code>labels</code>: High-symmetry point labels (index, label)</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.compute_bands"><a class="docstring-binding" href="#PhoXonic.compute_bands"><code>PhoXonic.compute_bands</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_bands(solver::Solver, kpath; bands=1:10, verbose=false)</code></pre><p>Compute band structure along a k-point path.</p><p>When the solver uses LOBPCGMethod with warm_start=true, automatically:</p><ol><li>Solves first k-point with Dense (if first_dense=true)</li><li>Uses previous eigenvectors as initial guess for subsequent k-points</li><li>Applies matrix scaling (if scale=true)</li></ol><p>This can achieve up to 38x speedup for large problems.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: The solver</li><li><code>kpath</code>: K-point path (SimpleKPath, KPathInterpolant, or Vector)</li><li><code>bands</code>: Which bands to compute (default: 1:10)</li><li><code>verbose</code>: Print progress (default: false)</li></ul><p><strong>Returns</strong></p><p>A <code>BandStructure</code> object containing frequencies for each k-point and band.</p></div></section><section><div><pre><code class="language-julia hljs">compute_bands(solver::Solver, kpoints::Vector; bands=1:10)</code></pre><p>Compute band structure at specified k-points (without path structure).</p></div></section><section><div><pre><code class="language-julia hljs">compute_bands(solver::Solver, kpi::KPathInterpolant; bands=1:10, verbose=false)</code></pre><p>Compute band structure using Brillouin.jl KPathInterpolant.</p></div></section><section><div><pre><code class="language-julia hljs">compute_bands(solver::Solver{Dim3}, kpath::SimpleKPath{3}; bands=1:10, verbose=false)</code></pre><p>Compute 3D band structure along a k-point path.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: 3D solver (FullVectorEM or FullElastic)</li><li><code>kpath</code>: K-point path from <code>simple_kpath_cubic</code>, <code>simple_kpath_fcc</code>, etc.</li><li><code>bands</code>: Which bands to compute (default: 1:10)</li><li><code>verbose</code>: Print progress (default: false)</li></ul><p><strong>Returns</strong></p><p>A <code>BandStructure{3}</code> object containing frequencies for each k-point and band.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">lat = fcc_lattice(1.0)
geo = Geometry(lat, Dielectric(1.0), [(Sphere([0,0,0], 0.25), Dielectric(12.0))])
solver = Solver(FullVectorEM(), geo, (12,12,12), KrylovKitMethod(shift=0.01); cutoff=3)
kpath = simple_kpath_fcc(a=1.0, npoints=20)
bands = compute_bands(solver, kpath; bands=1:6)</code></pre><p><strong>Note</strong></p><p>At Γ point (k=0), the lowest transverse modes also have ω→0, which can cause anomalous values. Consider using a small k offset or skipping the Γ point.</p></div></section><section><div><pre><code class="language-julia hljs">compute_bands(solver::Solver{Dim3}, kpoints::Vector; bands=1:10, verbose=false)</code></pre><p>Compute 3D band structure at specified k-points (without path structure).</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: 3D solver (FullVectorEM or FullElastic)</li><li><code>kpoints</code>: Vector of k-points as 3-element vectors</li><li><code>bands</code>: Which bands to compute (default: 1:10)</li><li><code>verbose</code>: Print progress (default: false)</li></ul><p><strong>Returns</strong></p><p>A <code>BandStructure{3}</code> object. Labels will be empty since no path structure is provided.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">kpoints = [[0.5, 0.0, 0.0], [0.5, 0.5, 0.0], [0.5, 0.5, 0.5]]
bands = compute_bands(solver, kpoints; bands=1:6)</code></pre></div></section><section><div><pre><code class="language-julia hljs">compute_bands(solver::Solver{Dim3}, kpi::KPathInterpolant; bands=1:10, verbose=false)</code></pre><p>Compute 3D band structure using Brillouin.jl KPathInterpolant.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: 3D solver (FullVectorEM or FullElastic)</li><li><code>kpi</code>: K-path interpolant from <code>kpath_cubic</code>, <code>kpath_fcc</code>, <code>kpath_bcc</code>, etc.</li><li><code>bands</code>: Which bands to compute (default: 1:10)</li><li><code>verbose</code>: Print progress (default: false)</li></ul><p><strong>Returns</strong></p><p>A <code>BandStructure{3}</code> object.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">lat = cubic_lattice(1.0)
geo = Geometry(lat, Dielectric(1.0), [(Sphere([0,0,0], 0.3), Dielectric(12.0))])
solver = Solver(FullVectorEM(), geo, (12,12,12), KrylovKitMethod(shift=0.01); cutoff=3)
kpath = kpath_cubic(a=1.0, N=50)  # Brillouin.jl based
bands = compute_bands(solver, kpath; bands=1:6)</code></pre></div></section><section><div><pre><code class="language-julia hljs">compute_bands(solver, kpath; kwargs...)</code></pre><p>Compute band structure along a k-path.</p><p>See concrete method signatures for detailed documentation and keyword arguments.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.find_bandgap"><a class="docstring-binding" href="#PhoXonic.find_bandgap"><code>PhoXonic.find_bandgap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">find_bandgap(bs::BandStructure, band1::Int, band2::Int)</code></pre><p>Find the band gap between band1 and band2.</p><p><strong>Returns</strong></p><p>Named tuple with:</p><ul><li><code>gap</code>: Band gap width (0 if bands overlap)</li><li><code>gap_ratio</code>: Gap-to-midgap ratio</li><li><code>min_upper</code>: Minimum of upper band</li><li><code>max_lower</code>: Maximum of lower band</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.find_all_gaps"><a class="docstring-binding" href="#PhoXonic.find_all_gaps"><code>PhoXonic.find_all_gaps</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">find_all_gaps(bs::BandStructure; threshold=0.0)</code></pre><p>Find all band gaps in the band structure.</p><p><strong>Returns</strong></p><p>Vector of named tuples with gap information.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.frequencies"><a class="docstring-binding" href="#PhoXonic.frequencies"><code>PhoXonic.frequencies</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">frequencies(bs::BandStructure)</code></pre><p>Return the frequency matrix.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.distances"><a class="docstring-binding" href="#PhoXonic.distances"><code>PhoXonic.distances</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">distances(bs::BandStructure)</code></pre><p>Return the cumulative distances along the k-path.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.labels"><a class="docstring-binding" href="#PhoXonic.labels"><code>PhoXonic.labels</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">labels(bs::BandStructure)</code></pre><p>Return the high-symmetry point labels.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.nbands"><a class="docstring-binding" href="#PhoXonic.nbands"><code>PhoXonic.nbands</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nbands(bs::BandStructure)</code></pre><p>Return the number of bands.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.nkpoints"><a class="docstring-binding" href="#PhoXonic.nkpoints"><code>PhoXonic.nkpoints</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nkpoints(bs::BandStructure)</code></pre><p>Return the number of k-points.</p></div></section></details></article><h2 id="K-path"><a class="docs-heading-anchor" href="#K-path">K-path</a><a id="K-path-1"></a><a class="docs-heading-anchor-permalink" href="#K-path" title="Permalink"></a></h2><h3 id="Simple-K-paths"><a class="docs-heading-anchor" href="#Simple-K-paths">Simple K-paths</a><a id="Simple-K-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-K-paths" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PhoXonic.SimpleKPath"><a class="docstring-binding" href="#PhoXonic.SimpleKPath"><code>PhoXonic.SimpleKPath</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SimpleKPath{D}</code></pre><p>A simple k-path structure for basic band structure calculations. Use this when Brillouin.jl&#39;s full functionality is not needed.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.simple_kpath_square"><a class="docstring-binding" href="#PhoXonic.simple_kpath_square"><code>PhoXonic.simple_kpath_square</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simple_kpath_square(; a=1.0, npoints=50)</code></pre><p>Create a simple k-path for square lattice without Brillouin.jl. Γ → X → M → Γ</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.simple_kpath_hexagonal"><a class="docstring-binding" href="#PhoXonic.simple_kpath_hexagonal"><code>PhoXonic.simple_kpath_hexagonal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simple_kpath_hexagonal(; a=1.0, npoints=50)</code></pre><p>Create a simple k-path for hexagonal lattice without Brillouin.jl. Γ → M → K → Γ</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.simple_kpath_cubic"><a class="docstring-binding" href="#PhoXonic.simple_kpath_cubic"><code>PhoXonic.simple_kpath_cubic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simple_kpath_cubic(; a=1.0, npoints=50)</code></pre><p>Create a simple k-path for simple cubic (SC) lattice.</p><p>Path: Γ → X → M → Γ → R → X</p><p>High-symmetry points (in units of 2π/a):</p><ul><li>Γ = (0, 0, 0)</li><li>X = (1/2, 0, 0)</li><li>M = (1/2, 1/2, 0)</li><li>R = (1/2, 1/2, 1/2)</li></ul><p><strong>Arguments</strong></p><ul><li><code>a</code>: Lattice constant (default: 1.0)</li><li><code>npoints</code>: Number of points per segment (default: 50)</li></ul><p><strong>Returns</strong></p><p>A <code>SimpleKPath{3}</code> object that can be passed to <code>compute_bands</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">lat = cubic_lattice(1.0)
geo = Geometry(lat, Dielectric(1.0), [(Sphere([0,0,0], 0.3), Dielectric(12.0))])
solver = Solver(FullVectorEM(), geo, (12,12,12), KrylovKitMethod(shift=0.01); cutoff=3)
kpath = simple_kpath_cubic(a=1.0, npoints=30)
bands = compute_bands(solver, kpath; bands=1:6)</code></pre><p>See also: <a href="#PhoXonic.kpath_cubic"><code>kpath_cubic</code></a> for Brillouin.jl-based k-path, <a href="https://thchr.github.io/Brillouin.jl/stable/">Brillouin.jl documentation</a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.simple_kpath_fcc"><a class="docstring-binding" href="#PhoXonic.simple_kpath_fcc"><code>PhoXonic.simple_kpath_fcc</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simple_kpath_fcc(; a=1.0, npoints=50)</code></pre><p>Create a simple k-path for face-centered cubic (FCC) lattice.</p><p>Path: Γ → X → W → L → Γ → K</p><p>High-symmetry points (values shown are multiplied by 2π/a to give Cartesian coordinates):</p><ul><li>Γ = (0, 0, 0)</li><li>X = (0, 1, 0) × 2π/a</li><li>W = (1/2, 1, 0) × 2π/a</li><li>L = (1/2, 1/2, 1/2) × 2π/a</li><li>K = (3/4, 3/4, 0) × 2π/a</li></ul><p><strong>Arguments</strong></p><ul><li><code>a</code>: Conventional lattice constant (default: 1.0)</li><li><code>npoints</code>: Number of points per segment (default: 50)</li></ul><p><strong>Returns</strong></p><p>A <code>SimpleKPath{3}</code> object that can be passed to <code>compute_bands</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">lat = fcc_lattice(1.0)
geo = Geometry(lat, Dielectric(1.0), [(Sphere([0,0,0], 0.25), Dielectric(12.0))])
solver = Solver(FullVectorEM(), geo, (12,12,12), KrylovKitMethod(shift=0.01); cutoff=3)
kpath = simple_kpath_fcc(a=1.0, npoints=30)
bands = compute_bands(solver, kpath; bands=1:6)</code></pre><p>See also: <a href="#PhoXonic.kpath_fcc"><code>kpath_fcc</code></a> for Brillouin.jl-based k-path, <a href="https://thchr.github.io/Brillouin.jl/stable/">Brillouin.jl documentation</a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.simple_kpath_bcc"><a class="docstring-binding" href="#PhoXonic.simple_kpath_bcc"><code>PhoXonic.simple_kpath_bcc</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simple_kpath_bcc(; a=1.0, npoints=50)</code></pre><p>Create a simple k-path for body-centered cubic (BCC) lattice.</p><p>Path: Γ → H → N → Γ → P → H</p><p>High-symmetry points (values shown are multiplied by 2π/a to give Cartesian coordinates):</p><ul><li>Γ = (0, 0, 0)</li><li>H = (0, 0, 1) × 2π/a</li><li>N = (0, 1/2, 1/2) × 2π/a</li><li>P = (1/4, 1/4, 1/4) × 2π/a</li></ul><p><strong>Arguments</strong></p><ul><li><code>a</code>: Conventional lattice constant (default: 1.0)</li><li><code>npoints</code>: Number of points per segment (default: 50)</li></ul><p><strong>Returns</strong></p><p>A <code>SimpleKPath{3}</code> object that can be passed to <code>compute_bands</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">kpath = simple_kpath_bcc(a=1.0, npoints=30)
bands = compute_bands(solver, kpath; bands=1:6)</code></pre><p>See also: <a href="#PhoXonic.kpath_bcc"><code>kpath_bcc</code></a> for Brillouin.jl-based k-path, <a href="https://thchr.github.io/Brillouin.jl/stable/">Brillouin.jl documentation</a></p></div></section></details></article><h3 id="[Brillouin.jl](https://thchr.github.io/Brillouin.jl/stable/)-Integration"><a class="docs-heading-anchor" href="#[Brillouin.jl](https://thchr.github.io/Brillouin.jl/stable/)-Integration"><a href="https://thchr.github.io/Brillouin.jl/stable/">Brillouin.jl</a> Integration</a><a id="[Brillouin.jl](https://thchr.github.io/Brillouin.jl/stable/)-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#[Brillouin.jl](https://thchr.github.io/Brillouin.jl/stable/)-Integration" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PhoXonic.kpath_from_brillouin"><a class="docstring-binding" href="#PhoXonic.kpath_from_brillouin"><code>PhoXonic.kpath_from_brillouin</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpath_from_brillouin(sgnum::Int, Rs; N=100)</code></pre><p>Create a k-path using Brillouin.jl&#39;s irrfbz_path.</p><p><strong>Arguments</strong></p><ul><li><code>sgnum</code>: Space group number (e.g., 1 for P1, 227 for diamond)</li><li><code>Rs</code>: Direct lattice vectors as a matrix or vector of vectors</li><li><code>N</code>: Number of interpolation points (default: 100)</li></ul><p><strong>Returns</strong></p><p>A KPathInterpolant that can be iterated over.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Square lattice (space group 1, primitive cell)
Rs = [[1.0, 0.0], [0.0, 1.0]]
kpi = kpath_from_brillouin(1, Rs; N=100)

# Iterate over k-points
for k in kpi
    # k is an SVector
end</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.kpath_square"><a class="docstring-binding" href="#PhoXonic.kpath_square"><code>PhoXonic.kpath_square</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpath_square(; a=1.0, N=100)</code></pre><p>Create a standard k-path for a 2D square lattice: Γ → X → M → Γ</p><p>Uses Brillouin.jl with space group 1 (P1).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.kpath_hexagonal"><a class="docstring-binding" href="#PhoXonic.kpath_hexagonal"><code>PhoXonic.kpath_hexagonal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpath_hexagonal(; a=1.0, N=100)</code></pre><p>Create a standard k-path for a 2D hexagonal lattice: Γ → M → K → Γ</p><p>Uses Brillouin.jl with appropriate space group.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.kpath_cubic"><a class="docstring-binding" href="#PhoXonic.kpath_cubic"><code>PhoXonic.kpath_cubic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpath_cubic(; a=1.0, N=100)</code></pre><p>Create a k-path for simple cubic (SC) lattice using <a href="https://thchr.github.io/Brillouin.jl/stable/">Brillouin.jl</a>.</p><p>Path: Γ → X → M → Γ → R → X | R → M</p><p>Uses space group 221 (Pm-3m).</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: Lattice constant (default: 1.0)</li><li><code>N</code>: Number of interpolation points (default: 100)</li></ul><p><strong>Returns</strong></p><p>A <code>KPathInterpolant</code> from Brillouin.jl that can be passed to <code>compute_bands</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">lat = cubic_lattice(1.0)
geo = Geometry(lat, Dielectric(1.0), [(Sphere([0,0,0], 0.3), Dielectric(12.0))])
solver = Solver(FullVectorEM(), geo, (12,12,12), KrylovKitMethod(shift=0.01); cutoff=3)
kpath = kpath_cubic(a=1.0, N=100)
bands = compute_bands(solver, kpath; bands=1:6)</code></pre><p>Reference: Setyawan &amp; Curtarolo, Comp. Mat. Sci. 49, 299 (2010). <a href="https://doi.org/10.1016/j.commatsci.2010.05.010">DOI:10.1016/j.commatsci.2010.05.010</a></p><p>See also: <a href="https://thchr.github.io/Brillouin.jl/stable/api/#Brillouin.irrfbz_path">Brillouin.jl <code>irrfbz_path</code></a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.kpath_fcc"><a class="docstring-binding" href="#PhoXonic.kpath_fcc"><code>PhoXonic.kpath_fcc</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpath_fcc(; a=1.0, N=100)</code></pre><p>Create a k-path for face-centered cubic (FCC) lattice using <a href="https://thchr.github.io/Brillouin.jl/stable/">Brillouin.jl</a>.</p><p>Path: Γ → X → U | K → Γ → L → W → X</p><p>Uses space group 225 (Fm-3m).</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: Conventional lattice constant (default: 1.0)</li><li><code>N</code>: Number of interpolation points (default: 100)</li></ul><p><strong>Returns</strong></p><p>A <code>KPathInterpolant</code> from Brillouin.jl that can be passed to <code>compute_bands</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">lat = fcc_lattice(1.0)
geo = Geometry(lat, Dielectric(1.0), [(Sphere([0,0,0], 0.25), Dielectric(12.0))])
solver = Solver(FullVectorEM(), geo, (12,12,12), KrylovKitMethod(shift=0.01); cutoff=3)
kpath = kpath_fcc(a=1.0, N=100)
bands = compute_bands(solver, kpath; bands=1:6)</code></pre><p>Reference: Setyawan &amp; Curtarolo, Comp. Mat. Sci. 49, 299 (2010). <a href="https://doi.org/10.1016/j.commatsci.2010.05.010">DOI:10.1016/j.commatsci.2010.05.010</a></p><p>See also: <a href="https://thchr.github.io/Brillouin.jl/stable/api/#Brillouin.irrfbz_path">Brillouin.jl <code>irrfbz_path</code></a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="PhoXonic.kpath_bcc"><a class="docstring-binding" href="#PhoXonic.kpath_bcc"><code>PhoXonic.kpath_bcc</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpath_bcc(; a=1.0, N=100)</code></pre><p>Create a k-path for body-centered cubic (BCC) lattice using <a href="https://thchr.github.io/Brillouin.jl/stable/">Brillouin.jl</a>.</p><p>Path: Γ → H → N → Γ → P → H | P → N</p><p>Uses space group 229 (Im-3m).</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: Conventional lattice constant (default: 1.0)</li><li><code>N</code>: Number of interpolation points (default: 100)</li></ul><p><strong>Returns</strong></p><p>A <code>KPathInterpolant</code> from Brillouin.jl that can be passed to <code>compute_bands</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">kpath = kpath_bcc(a=1.0, N=100)
bands = compute_bands(solver, kpath; bands=1:6)</code></pre><p>Reference: Setyawan &amp; Curtarolo, Comp. Mat. Sci. 49, 299 (2010). <a href="https://doi.org/10.1016/j.commatsci.2010.05.010">DOI:10.1016/j.commatsci.2010.05.010</a></p><p>See also: <a href="https://thchr.github.io/Brillouin.jl/stable/api/#Brillouin.irrfbz_path">Brillouin.jl <code>irrfbz_path</code></a></p></div></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« Core</a><a class="docs-footer-nextpage" href="../api-advanced/">Advanced »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 25 December 2025 13:44">Thursday 25 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

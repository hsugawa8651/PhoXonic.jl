<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Matrix-Free Methods · PhoXonic.jl</title><meta name="title" content="Matrix-Free Methods · PhoXonic.jl"/><meta property="og:title" content="Matrix-Free Methods · PhoXonic.jl"/><meta property="twitter:title" content="Matrix-Free Methods · PhoXonic.jl"/><meta name="description" content="Documentation for PhoXonic.jl."/><meta property="og:description" content="Documentation for PhoXonic.jl."/><meta property="twitter:description" content="Documentation for PhoXonic.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PhoXonic.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../workflow/">Workflow (2D)</a></li><li><a class="tocitem" href="../workflow_1d/">1D Calculations</a></li><li><a class="tocitem" href="../workflow_3d/">3D Calculations</a></li><li><a class="tocitem" href="../solver/">Solver Methods</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li><a class="tocitem" href="../greens_function/">DOS / LDOS</a></li><li><a class="tocitem" href="../topology/">Topological Invariants</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Matrix-Free Methods</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Grid-Resolution-Constraint"><span>Grid Resolution Constraint</span></a></li><li><a class="tocitem" href="#Usage-with-Iterative-Eigensolvers"><span>Usage with Iterative Eigensolvers</span></a></li><li><a class="tocitem" href="#Unified-Green&#39;s-Function-API"><span>Unified Green&#39;s Function API</span></a></li><li><a class="tocitem" href="#Low-Level-API"><span>Low-Level API</span></a></li><li><a class="tocitem" href="#Performance-Tips"><span>Performance Tips</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li></ul></li><li><a class="tocitem" href="../elastic_void/">Elastic Void (Tanaka Limit)</a></li><li><a class="tocitem" href="../tmm/">Transfer Matrix Method (1D)</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Core</a></li><li><a class="tocitem" href="../api-solver/">Solver</a></li><li><a class="tocitem" href="../api-advanced/">Advanced</a></li><li><a class="tocitem" href="../api-plotting/">Plotting</a></li><li><a class="tocitem" href="../api-io/">I/O</a></li></ul></li><li><a class="tocitem" href="../dependencies/">Dependencies</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Matrix-Free Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Matrix-Free Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hsugawa8651/PhoXonic.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/docs/src/matrixfree.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Matrix-Free-Methods"><a class="docs-heading-anchor" href="#Matrix-Free-Methods">Matrix-Free Methods</a><a id="Matrix-Free-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Free-Methods" title="Permalink"></a></h1><p>PhoXonic.jl provides matrix-free implementations for large-scale calculations where storing dense matrices is prohibitive.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><h3 id="Memory-and-Computational-Complexity"><a class="docs-heading-anchor" href="#Memory-and-Computational-Complexity">Memory and Computational Complexity</a><a id="Memory-and-Computational-Complexity-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-and-Computational-Complexity" title="Permalink"></a></h3><table><tr><th style="text-align: right">Operation</th><th style="text-align: right">Dense</th><th style="text-align: right">Matrix-Free</th></tr><tr><td style="text-align: right">Memory</td><td style="text-align: right">O(N²)</td><td style="text-align: right">O(N)</td></tr><tr><td style="text-align: right">Matrix construction</td><td style="text-align: right">O(N³)</td><td style="text-align: right">O(N)</td></tr><tr><td style="text-align: right">Matrix-vector product</td><td style="text-align: right">O(N²)</td><td style="text-align: right">O(N log N)</td></tr></table><p>For a 3D calculation with N = 10,000 plane waves and 3 components:</p><ul><li><strong>Dense</strong>: ~14 GB for matrices</li><li><strong>Matrix-free</strong>: ~few MB</li></ul><h3 id="Supported-Wave-Types"><a class="docs-heading-anchor" href="#Supported-Wave-Types">Supported Wave Types</a><a id="Supported-Wave-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-Wave-Types" title="Permalink"></a></h3><table><tr><th style="text-align: right">Wave Type</th><th style="text-align: right">Dimension</th><th style="text-align: right">LHS FFTs</th><th style="text-align: right">RHS FFTs</th></tr><tr><td style="text-align: right">TEWave</td><td style="text-align: right">2D</td><td style="text-align: right">4</td><td style="text-align: right">2</td></tr><tr><td style="text-align: right">TMWave</td><td style="text-align: right">2D</td><td style="text-align: right">4</td><td style="text-align: right">2</td></tr><tr><td style="text-align: right">SHWave</td><td style="text-align: right">2D</td><td style="text-align: right">4</td><td style="text-align: right">2</td></tr><tr><td style="text-align: right">PSVWave</td><td style="text-align: right">2D</td><td style="text-align: right">16</td><td style="text-align: right">4</td></tr><tr><td style="text-align: right">Photonic1D</td><td style="text-align: right">1D</td><td style="text-align: right">2</td><td style="text-align: right">2</td></tr><tr><td style="text-align: right">Longitudinal1D</td><td style="text-align: right">1D</td><td style="text-align: right">2</td><td style="text-align: right">2</td></tr><tr><td style="text-align: right">FullVectorEM</td><td style="text-align: right">3D</td><td style="text-align: right">24</td><td style="text-align: right">6</td></tr><tr><td style="text-align: right">FullElastic</td><td style="text-align: right">3D</td><td style="text-align: right">42</td><td style="text-align: right">6</td></tr></table><h2 id="Grid-Resolution-Constraint"><a class="docs-heading-anchor" href="#Grid-Resolution-Constraint">Grid Resolution Constraint</a><a id="Grid-Resolution-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-Resolution-Constraint" title="Permalink"></a></h2><div class="admonition is-warning" id="Important-7d1028108ccc1c0"><header class="admonition-header">Important<a class="admonition-anchor" href="#Important-7d1028108ccc1c0" title="Permalink"></a></header><div class="admonition-body"><p>The solver&#39;s grid resolution must be large enough to contain all plane wave indices.</p></div></div><p>The required resolution in each dimension is:</p><pre><code class="nohighlight hljs">resolution &gt;= 2 * cutoff + 1</code></pre><table><tr><th style="text-align: right">Cutoff</th><th style="text-align: right">Min Resolution</th><th style="text-align: right">Recommended</th></tr><tr><td style="text-align: right">7 (default)</td><td style="text-align: right">15</td><td style="text-align: right">16 or 32</td></tr><tr><td style="text-align: right">10</td><td style="text-align: right">21</td><td style="text-align: right">32</td></tr><tr><td style="text-align: right">15</td><td style="text-align: right">31</td><td style="text-align: right">32</td></tr></table><h3 id="Dense-vs-Matrix-Free-Equivalence"><a class="docs-heading-anchor" href="#Dense-vs-Matrix-Free-Equivalence">Dense vs Matrix-Free Equivalence</a><a id="Dense-vs-Matrix-Free-Equivalence-1"></a><a class="docs-heading-anchor-permalink" href="#Dense-vs-Matrix-Free-Equivalence" title="Permalink"></a></h3><p>When the resolution constraint is satisfied, matrix-free and dense methods produce <strong>mathematically identical results</strong> (up to floating-point rounding errors ~10⁻¹⁵).</p><p><strong>Dense method</strong> (convolution matrix):</p><pre><code class="nohighlight hljs">M[i,j] = ε̃(Gᵢ - Gⱼ)
y = M * x                    # O(N²) matrix-vector product</code></pre><p><strong>Matrix-free method</strong> (FFT-based):</p><pre><code class="nohighlight hljs">y = FFT{ ε(r) · iFFT{x} }    # O(N log N) via FFT</code></pre><p>By the convolution theorem of discrete FFT, both compute the same cyclic convolution.</p><h3 id="Why-Aliasing-Occurs"><a class="docs-heading-anchor" href="#Why-Aliasing-Occurs">Why Aliasing Occurs</a><a id="Why-Aliasing-Occurs-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Aliasing-Occurs" title="Permalink"></a></h3><p>When the grid is too small, <strong>aliasing</strong> corrupts the results:</p><pre><code class="nohighlight hljs">cutoff=7 → plane wave indices: -7 to +7

With resolution 16×16:
  - Grid can hold indices -8 to +7
  - Problem: multiplying two plane waves extends the range
    Example: G=5 × G=5 → needs G=10, but grid can only hold up to G=7
  - High-frequency components wrap around (cyclic convolution artifact)
  - Result: ~4% error

With resolution 32×32:
  - Grid can hold indices -16 to +15
  - Sufficient margin for all products of plane waves
  - Result: ~10⁻¹⁶ error (machine precision)</code></pre><h3 id="Example:-Correct-vs-Incorrect-Resolution"><a class="docs-heading-anchor" href="#Example:-Correct-vs-Incorrect-Resolution">Example: Correct vs Incorrect Resolution</a><a id="Example:-Correct-vs-Incorrect-Resolution-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Correct-vs-Incorrect-Resolution" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Incorrect: resolution too small for cutoff=7
solver_bad = Solver(TEWave(), geo, (8, 8); cutoff=7)  # Error ~96%

# Correct: resolution &gt;= 2*7+1 = 15
solver_good = Solver(TEWave(), geo, (16, 16); cutoff=7)  # Error ~10⁻¹⁶
solver_good = Solver(TEWave(), geo, (32, 32); cutoff=7)  # Also correct</code></pre><h2 id="Usage-with-Iterative-Eigensolvers"><a class="docs-heading-anchor" href="#Usage-with-Iterative-Eigensolvers">Usage with Iterative Eigensolvers</a><a id="Usage-with-Iterative-Eigensolvers-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-with-Iterative-Eigensolvers" title="Permalink"></a></h2><p>See also: <a href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/examples/208_solver_comparison.jl"><code>examples/208_solver_comparison.jl</code></a> - Dense vs LOBPCG performance comparison</p><p>Matrix-free operators are used automatically with iterative solvers:</p><pre><code class="language-julia hljs">using PhoXonic

# Create geometry
lat = square_lattice(1.0)
mat_rod = Dielectric(8.9)
mat_air = Dielectric(1.0)
rod = Circle([0.5, 0.5], 0.2)
geo = Geometry(lat, mat_air, [(rod, mat_rod)])

# Use resolution &gt;= 2*cutoff+1
solver = Solver(TEWave(), geo, (32, 32), KrylovKitMethod(); cutoff=7)

# Solve - uses matrix-free internally
k = [0.5, 0.0]
ω, modes = solve(solver, k; bands=1:5)</code></pre><p>For 3D calculations with matrix-free methods, <code>FullVectorEM</code> with shift-and-invert is used:</p><pre><code class="language-julia hljs">lat = cubic_lattice(1.0)
geo = Geometry(lat, Dielectric(1.0), [(Sphere([0.5,0.5,0.5], 0.3), Dielectric(12.0))])

# Resolution must be &gt;= 2*cutoff+1 in each dimension
solver = Solver(FullVectorEM(), geo, (16, 16, 16), KrylovKitMethod(shift=0.01); cutoff=7)
ω, modes = solve(solver, [0.1, 0.1, 0.1]; bands=1:6)</code></pre><p><strong>Note:</strong> For most 3D photonic crystal calculations, <code>TransverseEM</code> with <code>DenseMethod()</code> is recommended as it eliminates spurious modes without requiring shift-and-invert. See <a href="../workflow_3d/#3D-Calculations">3D Calculations</a> for details.</p><h2 id="Unified-Green&#39;s-Function-API"><a class="docs-heading-anchor" href="#Unified-Green&#39;s-Function-API">Unified Green&#39;s Function API</a><a id="Unified-Green&#39;s-Function-API-1"></a><a class="docs-heading-anchor-permalink" href="#Unified-Green&#39;s-Function-API" title="Permalink"></a></h2><p>PhoXonic provides a unified API for Green&#39;s function, DOS, and LDOS calculations. The same <code>GFMethod</code> types work with all three functions.</p><p>For detailed documentation on DOS/LDOS functions, see <a href="../greens_function/#DOS-/-LDOS">DOS / LDOS</a>.</p><h3 id="Available-Methods"><a class="docs-heading-anchor" href="#Available-Methods">Available Methods</a><a id="Available-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Methods" title="Permalink"></a></h3><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Memory</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><a href="../api-advanced/#PhoXonic.DirectGF"><code>DirectGF()</code></a></td><td style="text-align: right">O(N²)</td><td style="text-align: right">LU factorization, most accurate</td></tr><tr><td style="text-align: right"><a href="../api-advanced/#PhoXonic.RSKGF"><code>RSKGF()</code></a></td><td style="text-align: right">O(N²)</td><td style="text-align: right"><a href="https://github.com/hsugawa8651/ReducedShiftedKrylov.jl">ReducedShiftedKrylov.jl</a></td></tr><tr><td style="text-align: right"><a href="../api-advanced/#PhoXonic.MatrixFreeGF"><code>MatrixFreeGF()</code></a></td><td style="text-align: right">O(N)</td><td style="text-align: right">Matrix-free RSCG, best for large systems</td></tr></table><h3 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h3><pre><code class="language-julia hljs">using PhoXonic

solver = Solver(TEWave(), geo, (32, 32); cutoff=7)
k = [0.5, 0.0]
ω_values = [0.3, 0.4, 0.5, 0.6]
k_points = [[0.0, 0.0], [0.5, 0.0], [0.5, 0.5]]

# Default (DirectGF) - no method argument needed
G = compute_greens_function(solver, k, ω_values, source; η=1e-2)
dos = compute_dos(solver, ω_values, k_points; η=1e-2)
ldos = compute_ldos(solver, [0.5, 0.5], ω_values, k_points; η=1e-2)

# With explicit method
G = compute_greens_function(solver, k, ω_values, source, DirectGF(); η=1e-2)
dos = compute_dos(solver, ω_values, k_points, MatrixFreeGF(); η=1e-2)
ldos = compute_ldos(solver, [0.5, 0.5], ω_values, k_points, RSKGF(); η=1e-2)</code></pre><h3 id="MatrixFreeGF-Options"><a class="docs-heading-anchor" href="#MatrixFreeGF-Options">MatrixFreeGF Options</a><a id="MatrixFreeGF-Options-1"></a><a class="docs-heading-anchor-permalink" href="#MatrixFreeGF-Options" title="Permalink"></a></h3><p><code>MatrixFreeGF</code> has an <code>rhs_inv_method</code> option for RHS⁻¹ application:</p><table><tr><th style="text-align: right">Option</th><th style="text-align: right">Description</th><th style="text-align: right">Speed</th><th style="text-align: right">Accuracy</th></tr><tr><td style="text-align: right"><code>ApproximateRHSInv()</code></td><td style="text-align: right">Element-wise 1/ε (default)</td><td style="text-align: right">Fast</td><td style="text-align: right">Approximate for inhomogeneous media</td></tr><tr><td style="text-align: right"><code>CGRHSInv()</code></td><td style="text-align: right">Inner CG iteration</td><td style="text-align: right">Slower</td><td style="text-align: right">Exact</td></tr></table><pre><code class="language-julia hljs"># Fast approximate method (default)
ldos = compute_ldos(solver, pos, ω_values, k_points, MatrixFreeGF(); η=1e-2)

# Exact CG method
ldos = compute_ldos(solver, pos, ω_values, k_points, MatrixFreeGF(rhs_inv_method=CGRHSInv()); η=1e-2)

# CGRHSInv with custom parameters
ldos = compute_ldos(solver, pos, ω_values, k_points,
    MatrixFreeGF(rhs_inv_method=CGRHSInv(atol=1e-12, rtol=1e-12, maxiter=200)); η=1e-2)</code></pre><div class="admonition is-info" id="When-to-use-CGRHSInv-790005c87b7291cd"><header class="admonition-header">When to use CGRHSInv<a class="admonition-anchor" href="#When-to-use-CGRHSInv-790005c87b7291cd" title="Permalink"></a></header><div class="admonition-body"><ul><li><code>ApproximateRHSInv()</code> is sufficient for most cases, especially for peak detection</li><li>Use <code>CGRHSInv()</code> when accurate absolute values are needed for high-contrast structures</li></ul></div></div><div class="admonition is-warning" id="RSCG-Convergence-bf64643ca87319a3"><header class="admonition-header">RSCG Convergence<a class="admonition-anchor" href="#RSCG-Convergence-bf64643ca87319a3" title="Permalink"></a></header><div class="admonition-body"><p>The RSCG solver may not fully converge for all problems. This affects <code>RSKGF</code> and <code>MatrixFreeGF</code> equally.</p><p>Symptoms of incomplete convergence:</p><ul><li>Relative errors of a few percent compared to direct solve</li></ul><p>Mitigation strategies:</p><ul><li>Increase <code>itmax</code> parameter</li><li>Use smaller <code>η</code> (broadening) values</li><li>For critical applications, use <code>DirectGF()</code></li></ul></div></div><div class="admonition is-success" id="Practical-Usage-a40b958cc7c3bdfb"><header class="admonition-header">Practical Usage<a class="admonition-anchor" href="#Practical-Usage-a40b958cc7c3bdfb" title="Permalink"></a></header><div class="admonition-body"><p><strong><code>MatrixFreeGF()</code> is recommended for:</strong></p><ul><li>Peak/resonance frequency detection (accurate even without full convergence)</li><li>Large-scale calculations where Dense methods are memory-prohibitive</li><li>Qualitative spectral analysis</li></ul><p><strong><code>DirectGF()</code> is recommended for:</strong></p><ul><li>Accurate absolute LDOS/DOS values</li><li>Quantitative analysis requiring high precision</li><li>Smaller systems where O(N²) memory is acceptable</li></ul></div></div><h3 id="Method-Comparison"><a class="docs-heading-anchor" href="#Method-Comparison">Method Comparison</a><a id="Method-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Method-Comparison" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Direct solve - O(N²) memory, O(N³) per frequency
G_direct = compute_greens_function(solver, k, ω_values, source, DirectGF(); η=1e-2)

# Dense RSK - O(N²) memory, efficient for many frequencies
G_rsk = compute_greens_function(solver, k, ω_values, source, RSKGF(); η=1e-2)

# Matrix-free - O(N) memory, O(N log N) per iteration
G_mf = compute_greens_function(solver, k, ω_values, source, MatrixFreeGF(); η=1e-2)

# Matrix-free with exact RHS⁻¹
G_mf_cg = compute_greens_function(solver, k, ω_values, source, MatrixFreeGF(rhs_inv_method=CGRHSInv()); η=1e-2)</code></pre><h2 id="Low-Level-API"><a class="docs-heading-anchor" href="#Low-Level-API">Low-Level API</a><a id="Low-Level-API-1"></a><a class="docs-heading-anchor-permalink" href="#Low-Level-API" title="Permalink"></a></h2><h3 id="[FFTContext](api-advanced.md#PhoXonic.FFTContext)-and-[MatrixFreeWorkspace](api-advanced.md#PhoXonic.MatrixFreeWorkspace)"><a class="docs-heading-anchor" href="#[FFTContext](api-advanced.md#PhoXonic.FFTContext)-and-[MatrixFreeWorkspace](api-advanced.md#PhoXonic.MatrixFreeWorkspace)"><a href="../api-advanced/#PhoXonic.FFTContext">FFTContext</a> and <a href="../api-advanced/#PhoXonic.MatrixFreeWorkspace">MatrixFreeWorkspace</a></a><a id="[FFTContext](api-advanced.md#PhoXonic.FFTContext)-and-[MatrixFreeWorkspace](api-advanced.md#PhoXonic.MatrixFreeWorkspace)-1"></a><a class="docs-heading-anchor-permalink" href="#[FFTContext](api-advanced.md#PhoXonic.FFTContext)-and-[MatrixFreeWorkspace](api-advanced.md#PhoXonic.MatrixFreeWorkspace)" title="Permalink"></a></h3><p>For optimal performance in loops, separate FFT plan creation from workspace allocation:</p><pre><code class="language-julia hljs"># FFTContext: holds FFT plans (create once, reuse)
ctx = FFTContext(solver)

# MatrixFreeWorkspace: holds work arrays (one per thread)
workspace = MatrixFreeWorkspace(ctx)

# Create operator with explicit context and workspace
op = MatrixFreeOperator(solver, k, ctx, workspace)</code></pre><div class="admonition is-warning" id="Thread-Safety-e1a58efabaff13f8"><header class="admonition-header">Thread Safety<a class="admonition-anchor" href="#Thread-Safety-e1a58efabaff13f8" title="Permalink"></a></header><div class="admonition-body"><p><strong>FFT plan creation is NOT thread-safe</strong> (<a href="https://juliamath.github.io/FFTW.jl/stable/">FFTW.jl</a> limitation). Create <code>FFTContext</code> from a single thread before entering parallel regions.</p><p><strong>FFT plan execution IS thread-safe</strong>. The same <code>FFTContext</code> can be shared across threads, but each thread must have its own <code>MatrixFreeWorkspace</code> to avoid data races.</p></div></div><h3 id="[MatrixFreeOperator](api-advanced.md#PhoXonic.MatrixFreeOperator)"><a class="docs-heading-anchor" href="#[MatrixFreeOperator](api-advanced.md#PhoXonic.MatrixFreeOperator)"><a href="../api-advanced/#PhoXonic.MatrixFreeOperator">MatrixFreeOperator</a></a><a id="[MatrixFreeOperator](api-advanced.md#PhoXonic.MatrixFreeOperator)-1"></a><a class="docs-heading-anchor-permalink" href="#[MatrixFreeOperator](api-advanced.md#PhoXonic.MatrixFreeOperator)" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Simple usage (creates new FFT plans internally)
op = MatrixFreeOperator(solver, k)

# Optimized usage (reuse FFT plans)
ctx = FFTContext(solver)
workspace = MatrixFreeWorkspace(ctx)
op = MatrixFreeOperator(solver, k, ctx, workspace)

# Apply LHS: y = LHS * x
y = zeros(ComplexF64, N)
apply_lhs!(y, op, x)

# Apply RHS: y = RHS * x
apply_rhs!(y, op, x)</code></pre><h3 id="[MatrixFreeEffectiveHamiltonian](api-advanced.md#PhoXonic.MatrixFreeEffectiveHamiltonian)"><a class="docs-heading-anchor" href="#[MatrixFreeEffectiveHamiltonian](api-advanced.md#PhoXonic.MatrixFreeEffectiveHamiltonian)"><a href="../api-advanced/#PhoXonic.MatrixFreeEffectiveHamiltonian">MatrixFreeEffectiveHamiltonian</a></a><a id="[MatrixFreeEffectiveHamiltonian](api-advanced.md#PhoXonic.MatrixFreeEffectiveHamiltonian)-1"></a><a class="docs-heading-anchor-permalink" href="#[MatrixFreeEffectiveHamiltonian](api-advanced.md#PhoXonic.MatrixFreeEffectiveHamiltonian)" title="Permalink"></a></h3><p>For RSCG integration:</p><pre><code class="language-julia hljs"># Create effective Hamiltonian H = RHS⁻¹ * LHS
op = MatrixFreeOperator(solver, k)
H = MatrixFreeEffectiveHamiltonian(op)

# Negate for RSCG: A = -H
A = NegatedOperator(H)

# Solve (σI + A)x = b for multiple shifts
shifts = [ω^2 + im*η for ω in ω_values]
x_solutions, stats = ReducedShiftedKrylov.rscg(A, b, shifts)</code></pre><h3 id="LinearMap-Interface"><a class="docs-heading-anchor" href="#LinearMap-Interface">LinearMap Interface</a><a id="LinearMap-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#LinearMap-Interface" title="Permalink"></a></h3><pre><code class="language-julia hljs">using LinearMaps  # https://julialinearalgebra.github.io/LinearMaps.jl/stable/

# Convert to LinearMap for use with other iterative solvers
A_lhs = to_linear_map_lhs(op)  # LHS as LinearMap
B_rhs = to_linear_map_rhs(op)  # RHS as LinearMap</code></pre><h2 id="Performance-Tips"><a class="docs-heading-anchor" href="#Performance-Tips">Performance Tips</a><a id="Performance-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tips" title="Permalink"></a></h2><ol><li><p><strong>Choose resolution wisely</strong>: Use <code>resolution = 2^n</code> for optimal FFT performance (e.g., 16, 32, 64 instead of 15, 31, 63).</p></li><li><p><strong>Reuse FFT plans</strong>: Use <code>FFTContext</code> and <code>MatrixFreeWorkspace</code> to avoid recreating FFT plans in loops:</p><pre><code class="language-julia hljs">ctx = FFTContext(solver)           # Create once (not thread-safe)
workspace = MatrixFreeWorkspace(ctx)  # One per thread

for k in k_points
    op = MatrixFreeOperator(solver, k, ctx, workspace)
    # ... use op ...
end</code></pre></li><li><p><strong>Thread safety</strong>: FFT plan execution is thread-safe, but creation is not. For parallel k-point loops:</p><pre><code class="language-julia hljs">ctx = FFTContext(solver)  # Create once in main thread
Threads.@threads for k in k_points
    ws = MatrixFreeWorkspace(ctx)  # Each thread needs its own workspace
    op = MatrixFreeOperator(solver, k, ctx, ws)
    # ... use op ...
end</code></pre></li><li><p><strong>3D calculations</strong>: Matrix-free is essential for 3D. Dense matrices for N = 10,000 require ~14 GB, while matrix-free uses only a few MB.</p></li><li><p><strong>RSCG convergence</strong>: Matrix-free RSCG often converges better than dense RSCG due to better numerical conditioning.</p></li></ol><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><ul><li><a href="../api-advanced/">Advanced API</a> - MatrixFreeOperator, FFTContext, EffectiveHamiltonian</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><a class="docs-footer-nextpage" href="../elastic_void/">Elastic Void (Tanaka Limit) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 18 February 2026 07:44">Wednesday 18 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"dependencies/#Dependencies","page":"Dependencies","title":"Dependencies","text":"PhoXonic.jl uses the following packages:","category":"section"},{"location":"dependencies/#Core-Dependencies","page":"Dependencies","title":"Core Dependencies","text":"Package Description\nBrillouin.jl Brillouin zone paths and symmetry\nFFTW.jl FFT for matrix-free operators (O(N log N) convolution)\nStaticArrays.jl Fixed-size arrays for vectors\nLinearAlgebra Standard linear algebra (stdlib)\nLinearMaps.jl Lazy linear operators","category":"section"},{"location":"dependencies/#Iterative-Solvers","page":"Dependencies","title":"Iterative Solvers","text":"Package Description\nKrylovKit.jl Krylov subspace methods (Arnoldi, Lanczos)\nKrylov.jl CG, MINRES, and other Krylov methods\nIterativeSolvers.jl LOBPCG eigensolver","category":"section"},{"location":"dependencies/#Optional-Extensions","page":"Dependencies","title":"Optional Extensions","text":"Package Extension Description\nPlots.jl PhoXonicPlotsExt Band structure plotting\nReducedShiftedKrylov.jl PhoXonicReducedShiftedKrylovExt Matrix-free Green's function","category":"section"},{"location":"dependencies/#I/O","page":"Dependencies","title":"I/O","text":"Package Description\nJLD2.jl Save/load band structures","category":"section"},{"location":"workflow_3d/#3D-Calculations","page":"3D Calculations","title":"3D Calculations","text":"3D photonic and phononic crystal calculations have special considerations due to the vector nature of the fields and the presence of spurious modes.","category":"section"},{"location":"workflow_3d/#3D-Wave-Types","page":"3D Calculations","title":"3D Wave Types","text":"(Image: 3D Wave Polarizations)\n\nWave Type Field Components Description\nTransverseEM H_⊥ (2N basis) Recommended for 3D photonic crystals\nFullVectorEM Hx, Hy, H_z Full vector H-field (3N basis, includes spurious modes)\nFullElastic ux, uy, u_z Full elastic (1 P + 2 S modes per k)","category":"section"},{"location":"workflow_3d/#3D-Photonic-Crystals","page":"3D Calculations","title":"3D Photonic Crystals","text":"","category":"section"},{"location":"workflow_3d/#TransverseEM-vs-FullVectorEM","page":"3D Calculations","title":"TransverseEM vs FullVectorEM","text":"For 3D photonic crystal calculations, TransverseEM is strongly recommended over FullVectorEM:\n\nFeature TransverseEM FullVectorEM\nMatrix size 2N × 2N 3N × 3N\nSpurious modes None (∇·H = 0 enforced) N longitudinal modes at ω ≈ 0\nShift required No Yes (to filter spurious modes)\nMemory usage ~44% less Full\n\nTransverseEM expands the H-field in a transverse polarization basis where each plane wave has two orthonormal polarization vectors e₁, e₂ perpendicular to (k+G). This automatically satisfies the transversality constraint ∇·H = 0, eliminating spurious longitudinal modes.","category":"section"},{"location":"workflow_3d/#H-field-Formulation","page":"3D Calculations","title":"H-field Formulation","text":"The 3D implementation uses the H-field formulation:\n\n∇ × (ε⁻¹ ∇ × H) = (ω/c)² μ H\n\nTransverseEM (Recommended)\n\nTransverseEM expands the H-field in a transverse polarization basis:\n\nH_G = h₁(G) e₁(k+G) + h₂(G) e₂(k+G)\n\nwhere e₁ and e₂ are orthonormal vectors perpendicular to (k+G). This construction automatically satisfies ∇·H = 0, eliminating all spurious longitudinal modes.\n\n# TransverseEM: no spurious modes, no shift needed\nsolver = Solver(TransverseEM(), geo, (16, 16, 16), DenseMethod(); cutoff=5)\n\nFullVectorEM (Legacy)\n\nFullVectorEM uses Cartesian components (Hx, Hy, Hz), producing:\n\nN longitudinal modes with ω ≈ 0 (unphysical, violate ∇·H = 0)\n2N transverse modes with physical frequencies\n\nWhen using FullVectorEM, use shift > 0 to filter out spurious modes:\n\n# DenseMethod: post-hoc filtering\nsolver = Solver(FullVectorEM(), geo, (12, 12, 12), DenseMethod(shift=0.01); cutoff=7)\n\n# KrylovKitMethod: shift-and-invert\nsolver = Solver(FullVectorEM(), geo, (16, 16, 16), KrylovKitMethod(shift=0.01); cutoff=7)\n\nSee Solver Methods for details on shift-and-invert.","category":"section"},{"location":"workflow_3d/#Examples","page":"3D Calculations","title":"Examples","text":"FCC Lattice with Spheres\n\nSee also: examples/401_fcc_spheres.jl\n\nlat = fcc_lattice(1.0)\nair = Dielectric(1.0)\ndielectric = Dielectric(12.0)\ngeo = Geometry(lat, air, [(Sphere([0.0, 0.0, 0.0], 0.25), dielectric)])\n\n# TransverseEM: recommended for 3D photonic crystals\nsolver = Solver(TransverseEM(), geo, (16, 16, 16), DenseMethod(); cutoff=5)\n\nSimple Cubic Lattice\n\nSee also: examples/402_sc_spheres.jl\n\nlat = cubic_lattice(1.0)\ngeo = Geometry(lat, air, [(Sphere([0.0, 0.0, 0.0], 0.3), dielectric)])\n\nsolver = Solver(TransverseEM(), geo, (16, 16, 16), DenseMethod(); cutoff=5)\nkpath = simple_kpath_cubic(a=1.0, npoints=20)\nbands = compute_bands(solver, kpath; bands=1:6)\n\nMore Examples\n\nexamples/411_joannopoulos_ch6_fig3.jl - FCC lattice benchmark\nexamples/412_joannopoulos_ch6_fig8.jl - Diamond lattice\nexamples/413_mpb_diamond.jl - MPB comparison","category":"section"},{"location":"workflow_3d/#MPB-Benchmark","page":"3D Calculations","title":"MPB Benchmark","text":"PhoXonic 3D calculations have been validated against MIT Photonic Bands (MPB).\n\nSee also: examples/413_mpb_diamond.jl\n\nSimple Cubic (SC) Lattice\n\nFor SC lattice with ε=12 sphere (r=0.3):\n\ncutoff Plane waves Error vs MPB\n3 123 24%\n5 515 7%\n7 1419 < 1%\n\nRecommended settings for SC:\n\nresolution = (16, 16, 16)\ncutoff = 5\nsolver = Solver(TransverseEM(), geo, resolution, DenseMethod(); cutoff=cutoff)\n\nFCC Lattice\n\nFor FCC lattice with ε=12 sphere (r=0.25):\n\nRecommended settings for FCC:\n\nresolution = (16, 16, 16)\ncutoff = 5\nsolver = Solver(TransverseEM(), geo, resolution, DenseMethod(); cutoff=cutoff)\n\nImportant Notes on MPB Comparison\n\nLattice normalization: MPB internally normalizes primitive lattice vectors to unit length. This affects the fill fraction interpretation:\nPhoXonic FCC primitive vector: |a| = 1/√2 ≈ 0.707\nMPB FCC primitive vector: |a| = 1.0 (normalized)\nFrequency units:\nMPB: f = ω·a/(2πc)\nPhoXonic: ω (angular frequency with c=1)\nConversion: ωPhoXonic = 2π × fMPB\nFill fraction: With the same r=0.25:\nPhoXonic: ~26% fill\nMPB: ~9% fill\nFor exact comparison, match fill fractions or mean ε values.","category":"section"},{"location":"workflow_3d/#Cutoff-Convergence","page":"3D Calculations","title":"Cutoff Convergence","text":"For 3D photonic crystals with high dielectric contrast (ε > 10), sufficient plane waves are required for accurate band structure calculation.\n\nRecommended cutoff values:\n\nDielectric contrast Minimum cutoff\nε < 4 3–5\n4 ≤ ε < 10 5–7\nε ≥ 10 7+\n\nExample convergence test:\n\nfor cutoff in [3, 5, 7]\n    solver = Solver(TransverseEM(), geo, (16,16,16), DenseMethod(); cutoff=cutoff)\n    bands = compute_bands(solver, kpath; bands=1:6)\n    println(\"cutoff=$cutoff: ω₁ = $(bands.frequencies[1,1])\")\nend\n\nNote: Higher cutoff increases computation time significantly.","category":"section"},{"location":"workflow_3d/#3D-Phononic-Crystals","page":"3D Calculations","title":"3D Phononic Crystals","text":"","category":"section"},{"location":"workflow_3d/#FullElastic-(Experimental)","page":"3D Calculations","title":"FullElastic (Experimental)","text":"FullElastic is an experimental implementation for 3D phononic crystal calculations. It computes the full 3D elastic wave equation with three displacement components (ux, uy, u_z), producing 3 modes per k-point (1 longitudinal P-wave + 2 transverse S-waves).\n\nlat = cubic_lattice(0.01)  # 1 cm period\nepoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)\nsteel = IsotropicElastic(ρ=7800.0, λ=1.15e11, μ=8.28e10)\ngeo = Geometry(lat, epoxy, [(Sphere([0.0, 0.0, 0.0], 0.004), steel)])\n\nsolver = Solver(FullElastic(), geo, (16, 16, 16), KrylovKitMethod(shift=0.01); cutoff=5)","category":"section"},{"location":"workflow_3d/#Why-is-FullElastic-Challenging?","page":"3D Calculations","title":"Why is FullElastic Challenging?","text":"3D phononic calculations are more difficult than 3D photonic calculations for several reasons:\n\nNo transverse basis: Unlike TransverseEM for photonic crystals, there is no established transverse basis for elastic waves that eliminates spurious modes. Electromagnetic waves satisfy ∇·D = 0 (transverse condition), allowing a 2-component basis that automatically excludes spurious longitudinal modes. Elastic waves have both longitudinal (P) and transverse (S) components with no such simplification.\nLarge contrast in elastic moduli: Real materials have high elastic moduli contrast (e.g., Csteel / Cepoxy ~ 50), which causes numerical challenges regardless of the unit system.\nShift parameter sensitivity: Too small a shift fails to filter spurious modes; too large a shift may miss physical low-frequency modes. The optimal value depends on material properties and k-point.\nHigh memory and computation time: 3N × 3N matrices with N > 1000 plane waves require significant resources.\nLimited benchmarks: Unlike 3D photonic crystals (validated against MPB), 3D phononic benchmarks are less standardized in the literature.","category":"section"},{"location":"workflow_3d/#Common-Topics","page":"3D Calculations","title":"Common Topics","text":"","category":"section"},{"location":"workflow_3d/#3D-K-paths","page":"3D Calculations","title":"3D K-paths","text":"# FCC lattice\nkpath = simple_kpath_fcc(a=1.0, npoints=20)\n\n# Simple cubic\nkpath = simple_kpath_cubic(a=1.0, npoints=20)\n\n# BCC lattice\nkpath = simple_kpath_bcc(a=1.0, npoints=20)\n\nSee also: simple_kpath_fcc, simple_kpath_cubic, simple_kpath_bcc","category":"section"},{"location":"workflow_3d/#Memory-Considerations","page":"3D Calculations","title":"Memory Considerations","text":"3D calculations require significantly more memory than 2D:\n\nResolution Plane waves (cutoff=7) Dense matrix memory\n12×12×12 ~500 ~6 GB\n16×16×16 ~1400 ~47 GB\n20×20×20 ~2700 ~175 GB\n\nFor large 3D systems, use matrix-free methods. See Matrix-Free Methods.","category":"section"},{"location":"workflow_3d/#API-Reference","page":"3D Calculations","title":"API Reference","text":"Solver API - TransverseEM, FullVectorEM, FullElastic, Solver methods\nAdvanced API - Matrix-free operators","category":"section"},{"location":"api-plotting/#Plotting-API","page":"Plotting","title":"Plotting API","text":"Requires Plots.jl to be loaded.\n\nusing PhoXonic\nusing Plots  # Required for plotting functions","category":"section"},{"location":"api-plotting/#Functions","page":"Plotting","title":"Functions","text":"","category":"section"},{"location":"api-plotting/#PhoXonic.plot_bands","page":"Plotting","title":"PhoXonic.plot_bands","text":"plot_bands(bs::BandStructure; kwargs...)\n\nPlot a band structure diagram.\n\nArguments\n\nbs: BandStructure object from compute_bands()\n\nKeyword Arguments\n\ncolor: Line/marker color (default: :blue)\nlinewidth: Line width (default: 2)\nscatter: Use scatter plot instead of lines (default: false). Recommended for 3D band structures where Γ point anomalies may occur.\nmarkersize: Marker size for scatter plot (default: 3)\nmarkershape: Marker shape for scatter plot (default: :circle)\ntitle: Plot title (default: \"Band Structure\")\nylabel: Y-axis label (default: \"Frequency\")\nshow_gaps: Highlight band gaps (default: false)\ngap_color: Color for gap highlighting (default: :yellow)\ngap_alpha: Transparency for gap highlighting (default: 0.2)\nnormalize: Normalization factor for frequency (default: 1.0)\n\nReturns\n\nA Plots.jl plot object.\n\nExample\n\nusing PhoXonic, Plots\nsolver = Solver(TEWave(), geo, (64, 64))\nbands = compute_bands(solver, kpath)\np = plot_bands(bands; title=\"TE Bands\", show_gaps=true)\nsavefig(p, \"bands.png\")\n\n# For 3D, use scatter to avoid line artifacts at Γ point\np = plot_bands(bands; scatter=true, markersize=2)\n\n\n\n\n\n","category":"function"},{"location":"api-plotting/#PhoXonic.plot_bands!","page":"Plotting","title":"PhoXonic.plot_bands!","text":"plot_bands!(p, bs::BandStructure; kwargs...)\n\nAdd band structure to an existing plot.\n\n\n\n\n\n","category":"function"},{"location":"api-plotting/#PhoXonic.band_plot_data","page":"Plotting","title":"PhoXonic.band_plot_data","text":"band_plot_data(bs::BandStructure; normalize=1.0)\n\nExtract data for plotting a band structure.\n\nReturns a NamedTuple with:\n\ndistances: K-path distances\nfrequencies: Normalized frequency matrix\nlabel_positions: Positions of high-symmetry points\nlabel_names: Names of high-symmetry points\n\n\n\n\n\n","category":"function"},{"location":"api-io/#I/O-API","page":"I/O","title":"I/O API","text":"Requires JLD2.jl to be loaded.\n\nusing PhoXonic\nusing JLD2  # Required for I/O functions","category":"section"},{"location":"api-io/#Functions","page":"I/O","title":"Functions","text":"","category":"section"},{"location":"api-io/#PhoXonic.save_bands","page":"I/O","title":"PhoXonic.save_bands","text":"save_bands(filename, bands::BandStructure; compress=false, metadata=Dict())\n\nSave a band structure to a JLD2 file.\n\nArguments\n\nfilename: Path to the output file (should end with .jld2)\nbands: BandStructure object from compute_bands()\n\nKeyword Arguments\n\ncompress: Enable compression (default: false)\nmetadata: Additional metadata dictionary\n\nExample\n\nusing PhoXonic\n\nsolver = Solver(TEWave(), geo, (64, 64))\nbands = compute_bands(solver, kpath)\nsave_bands(\"te_bands.jld2\", bands)\n\nSaved Data\n\nThe file contains:\n\nfrequencies: Matrix of frequencies (nkpoints × nbands)\nkpoints: Vector of k-point coordinates\ndistances: Cumulative distances along k-path\nlabels: High-symmetry point labels and indices\nmetadata: Additional information (version, date, etc.)\n\n\n\n\n\n","category":"function"},{"location":"api-io/#PhoXonic.load_bands","page":"I/O","title":"PhoXonic.load_bands","text":"load_bands(filename) -> BandStructure\n\nLoad a band structure from a JLD2 file.\n\nArguments\n\nfilename: Path to the input file\n\nReturns\n\nA BandStructure object.\n\nExample\n\nusing PhoXonic\n\nbands = load_bands(\"te_bands.jld2\")\nplot_bands(bands)\n\n\n\n\n\n","category":"function"},{"location":"api-io/#PhoXonic.save_modes","page":"I/O","title":"PhoXonic.save_modes","text":"save_modes(filename, modes; k=nothing, frequencies=nothing, compress=false, metadata=Dict())\n\nSave eigenmodes to a JLD2 file.\n\nArguments\n\nfilename: Output file path\nmodes: Eigenmode matrix (N × nbands) from solve()\n\nKeyword Arguments\n\nk: Wave vector (optional, for reference)\nfrequencies: Corresponding frequencies (optional)\ncompress: Enable compression (default: false, requires CodecZlib.jl)\nmetadata: Additional metadata dictionary\n\nExample\n\nusing PhoXonic\n\nω, modes = solve(solver, k; bands=1:5)\nsave_modes(\"modes_at_k.jld2\", modes; k=k, frequencies=ω)\n\n\n\n\n\n","category":"function"},{"location":"api-io/#PhoXonic.load_modes","page":"I/O","title":"PhoXonic.load_modes","text":"load_modes(filename) -> NamedTuple\n\nLoad eigenmodes from a JLD2 file.\n\nReturns\n\nA NamedTuple with:\n\nmodes: The eigenmode matrix\nk: Wave vector (if saved)\nfrequencies: Frequencies (if saved)\nmetadata: Additional metadata\n\n\n\n\n\n","category":"function"},{"location":"api-io/#PhoXonic.save_epsilon","page":"I/O","title":"PhoXonic.save_epsilon","text":"save_epsilon(filename, solver::Solver; compress=false, metadata=Dict())\n\nSave discretized material arrays to a JLD2 file.\n\nFor photonic crystals, saves:\n\nepsilon: Dielectric constant\nepsilon_inv: Inverse dielectric constant\nmu: Permeability\n\nFor phononic crystals, saves:\n\nC11, C12, C44: Elastic constants (Voigt notation)\nrho: Density\n\nExample\n\nusing PhoXonic\n\nsolver = Solver(TEWave(), geo, (64, 64))\nsave_epsilon(\"epsilon.jld2\", solver)\n\n# For phononic\nsolver_ph = Solver(FullElastic(), geo_phononic, (16, 16, 16))\nsave_epsilon(\"elastic_constants.jld2\", solver_ph)\n\n\n\n\n\n","category":"function"},{"location":"api-io/#PhoXonic.load_epsilon","page":"I/O","title":"PhoXonic.load_epsilon","text":"load_epsilon(filename) -> NamedTuple\n\nLoad discretized material arrays from a JLD2 file.\n\nReturns\n\nA NamedTuple with the material arrays and metadata.\n\nFor photonic data: :ε, :ε_inv, :μ, :μ_inv For phononic data: :C11, :C12, :C44, :ρ Plus: :resolution, :wave_type, :metadata\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#Solver-API","page":"Solver","title":"Solver API","text":"","category":"section"},{"location":"api-solver/#Wave-Types","page":"Solver","title":"Wave Types","text":"","category":"section"},{"location":"api-solver/#Abstract-Types","page":"Solver","title":"Abstract Types","text":"","category":"section"},{"location":"api-solver/#2D-Wave-Types","page":"Solver","title":"2D Wave Types","text":"","category":"section"},{"location":"api-solver/#1D-Wave-Types","page":"Solver","title":"1D Wave Types","text":"","category":"section"},{"location":"api-solver/#3D-Wave-Types","page":"Solver","title":"3D Wave Types","text":"","category":"section"},{"location":"api-solver/#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"api-solver/#Solver-Types","page":"Solver","title":"Solver Types","text":"","category":"section"},{"location":"api-solver/#High-level-API","page":"Solver","title":"High-level API","text":"","category":"section"},{"location":"api-solver/#Mid-level-API","page":"Solver","title":"Mid-level API","text":"For custom algorithms and advanced analysis:","category":"section"},{"location":"api-solver/#Utilities","page":"Solver","title":"Utilities","text":"","category":"section"},{"location":"api-solver/#Solver-Method-Types","page":"Solver","title":"Solver Method Types","text":"","category":"section"},{"location":"api-solver/#Abstract-Types-2","page":"Solver","title":"Abstract Types","text":"","category":"section"},{"location":"api-solver/#Concrete-Methods","page":"Solver","title":"Concrete Methods","text":"","category":"section"},{"location":"api-solver/#Band-Structure","page":"Solver","title":"Band Structure","text":"","category":"section"},{"location":"api-solver/#K-path","page":"Solver","title":"K-path","text":"","category":"section"},{"location":"api-solver/#Simple-K-paths","page":"Solver","title":"Simple K-paths","text":"","category":"section"},{"location":"api-solver/#[Brillouin.jl](https://thchr.github.io/Brillouin.jl/stable/)-Integration","page":"Solver","title":"Brillouin.jl Integration","text":"","category":"section"},{"location":"api-solver/#PhoXonic.WaveType","page":"Solver","title":"PhoXonic.WaveType","text":"Abstract type for all wave types.\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.PhotonicWave","page":"Solver","title":"PhoXonic.PhotonicWave","text":"Abstract type for photonic (electromagnetic) waves.\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.PhononicWave","page":"Solver","title":"PhoXonic.PhononicWave","text":"Abstract type for phononic (elastic) waves.\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.TEWave","page":"Solver","title":"PhoXonic.TEWave","text":"TEWave <: PhotonicWave\n\nTransverse Electric polarization (H_z mode) for 2D photonic crystals.\n\nElectric field is in the xy-plane, magnetic field H is along z. The eigenvalue equation is: ∇×(ε⁻¹∇×Hz) = (ω/c)² μ Hz\n\nField Components\n\nSolved: H_z (scalar)\nDerived: Ex, Ey from H_z\n\nExample\n\nsolver = Solver(TEWave(), geo, (64, 64))\nsolver = Solver(TEWave(), geo, (64, 64), KrylovKitMethod())\nsolver = Solver(TEWave(), geo, (64, 64), LOBPCGMethod())\n\nSee also: TMWave, FullVectorEM\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.TMWave","page":"Solver","title":"PhoXonic.TMWave","text":"TMWave <: PhotonicWave\n\nTransverse Magnetic polarization (E_z mode) for 2D photonic crystals.\n\nMagnetic field is in the xy-plane, electric field E is along z. The eigenvalue equation is: ∇×(μ⁻¹∇×Ez) = (ω/c)² ε Ez\n\nField Components\n\nSolved: E_z (scalar)\nDerived: Hx, Hy from E_z\n\nExample\n\nsolver = Solver(TMWave(), geo, (64, 64))\nsolver = Solver(TMWave(), geo, (64, 64), KrylovKitMethod())\nsolver = Solver(TMWave(), geo, (64, 64), LOBPCGMethod())\n\nSee also: TEWave, FullVectorEM\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.SHWave","page":"Solver","title":"PhoXonic.SHWave","text":"SHWave <: PhononicWave\n\nShear Horizontal (out-of-plane, anti-plane) elastic wave for 2D phononic crystals.\n\nDisplacement uz is perpendicular to the xy-plane. The eigenvalue equation is: ∇·(C₄₄∇uz) = -ρω² u_z\n\nField Components\n\nSolved: u_z (scalar)\nDecoupled from in-plane (P-SV) modes\n\nNotes\n\nEigenvalues ω² can be O(10¹⁰) for typical materials\nKrylovKitMethod uses automatic scaling for numerical stability\nLOBPCGMethod works without explicit scaling\n\nExample\n\nsteel = IsotropicElastic(ρ=7800.0, λ=115e9, μ=82e9)\nepoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)\ngeo = Geometry(lat, epoxy, [(Circle([0,0], 0.3), steel)])\n\nsolver = Solver(SHWave(), geo, (64, 64))\nsolver = Solver(SHWave(), geo, (64, 64), KrylovKitMethod())\nsolver = Solver(SHWave(), geo, (64, 64), LOBPCGMethod())\n\nSee also: PSVWave, FullElastic\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.PSVWave","page":"Solver","title":"PhoXonic.PSVWave","text":"PSVWave <: PhononicWave\n\nP-SV (in-plane) elastic wave for 2D phononic crystals.\n\nDisplacement (ux, uy) is in the xy-plane, coupling P (longitudinal) and SV (shear vertical) polarizations.\n\nField Components\n\nSolved: ux, uy (2 components)\nProduces 2 bands per k-point (quasi-P and quasi-SV)\n\nNotes\n\nEigenvalues ω² can be O(10¹⁰) for typical materials\nKrylovKitMethod uses automatic scaling for numerical stability\nLOBPCGMethod works without explicit scaling\n\nExample\n\nsteel = IsotropicElastic(ρ=7800.0, λ=115e9, μ=82e9)\nepoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)\ngeo = Geometry(lat, epoxy, [(Circle([0,0], 0.3), steel)])\n\nsolver = Solver(PSVWave(), geo, (64, 64))\nsolver = Solver(PSVWave(), geo, (64, 64), KrylovKitMethod())\nsolver = Solver(PSVWave(), geo, (64, 64), LOBPCGMethod())\n\nSee also: SHWave, FullElastic\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.Photonic1D","page":"Solver","title":"PhoXonic.Photonic1D","text":"Photonic1D <: PhotonicWave\n\nScalar electromagnetic wave for 1D photonic structures (Bragg reflectors, etc.).\n\nThe eigenvalue equation is: -d/dx(ε⁻¹ d/dx E) = (ω/c)² E\n\nExample\n\nlat = lattice_1d(1.0)\ngeo = Geometry(lat, mat1, [(Segment(0.0, 0.5), mat2)])\nsolver = Solver(Photonic1D(), geo, 128; cutoff=20)\nsolver = Solver(Photonic1D(), geo, 128, KrylovKitMethod(); cutoff=20)\nsolver = Solver(Photonic1D(), geo, 128, LOBPCGMethod(); cutoff=20)\n\nSee also: TEWave, TMWave, Longitudinal1D\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.Longitudinal1D","page":"Solver","title":"PhoXonic.Longitudinal1D","text":"Longitudinal1D <: PhononicWave\n\nLongitudinal elastic wave for 1D phononic structures (superlattices, etc.).\n\nThe eigenvalue equation is: d/dx(C₁₁ du/dx) = -ρω² u\n\nNotes\n\nEigenvalues ω² can be O(10¹⁰) for typical materials\nKrylovKitMethod uses automatic scaling for numerical stability\nLOBPCGMethod works without explicit scaling\n\nExample\n\nlat = lattice_1d(1.0)\nsteel = IsotropicElastic(ρ=7800.0, λ=115e9, μ=82e9)\nepoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)\ngeo = Geometry(lat, epoxy, [(Segment(0.0, 0.5), steel)])\n\nsolver = Solver(Longitudinal1D(), geo, 128; cutoff=20)\nsolver = Solver(Longitudinal1D(), geo, 128, KrylovKitMethod(); cutoff=20)\nsolver = Solver(Longitudinal1D(), geo, 128, LOBPCGMethod(); cutoff=20)\n\nSee also: SHWave, PSVWave, Photonic1D\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.TransverseEM","page":"Solver","title":"PhoXonic.TransverseEM","text":"TransverseEM <: PhotonicWave\n\nTransverse electromagnetic wave for 3D photonic crystals (recommended).\n\nUses H-field formulation with transverse projection, ensuring ∇·H = 0. This is the MPB-compatible formulation for accurate band structure calculations.\n\nField Components\n\nBasis: 2 polarization vectors (e₁, e₂) perpendicular to k+G\nMatrix size: 2N×2N (vs 3N×3N for FullVectorEM)\nNo spurious longitudinal modes\n\nMathematical Formulation\n\nFor each plane wave G, the H field is expanded as:     H_G = h₁(G) e₁(G) + h₂(G) e₂(G) where e₁, e₂ are orthonormal vectors perpendicular to k+G.\n\nExample\n\nlat = fcc_lattice(1.0)\ngeo = Geometry(lat, air, [(Sphere([0,0,0], 0.25), dielectric)])\n\n# Recommended for band structure calculations\nsolver = Solver(TransverseEM(), geo, (16, 16, 16); cutoff=5)\nbands = compute_bands(solver, kpath; bands=1:10)\n\nSee also: FullVectorEM, TEWave, TMWave\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.FullVectorEM","page":"Solver","title":"PhoXonic.FullVectorEM","text":"FullVectorEM <: PhotonicWave\n\nFull vector electromagnetic wave for 3D photonic crystals.\n\nUses H-field formulation: ∇×(ε⁻¹∇×H) = (ω/c)² μ H\n\nField Components\n\nSolved: Hx, Hy, H_z (3 components)\nPhysical modes: 2 transverse modes per k-point\n\nNotes\n\nProduces spurious longitudinal modes at ω ≈ 0 (unphysical)\nUse shift parameter with iterative solvers to skip spurious modes\n\nExample\n\nlat = cubic_lattice(1.0)\ngeo = Geometry(lat, air, [(Sphere([0,0,0], 0.3), rod)])\nsolver = Solver(FullVectorEM(), geo, (16, 16, 16); cutoff=3)\n\n# Iterative solvers require shift to skip spurious modes\nsolver = Solver(FullVectorEM(), geo, (16, 16, 16), KrylovKitMethod(shift=0.01); cutoff=3)\nsolver = Solver(FullVectorEM(), geo, (16, 16, 16), LOBPCGMethod(shift=0.01); cutoff=3)\n\nSee also: TEWave, TMWave, FullElastic\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.FullElastic","page":"Solver","title":"PhoXonic.FullElastic","text":"FullElastic <: PhononicWave\n\nFull elastic wave for 3D phononic crystals.\n\nSolves the elastodynamic equation: ∇·σ = -ρω²u where σ = C:ε\n\nField Components\n\nSolved: ux, uy, u_z (3 components)\nProduces 3 bands per k-point (1 quasi-P + 2 quasi-S)\n\nNotes\n\nEigenvalues ω² can be O(10¹⁰) for typical materials\nUse shift parameter with iterative solvers for 3D\n\nExample\n\nlat = cubic_lattice(1.0)\nsteel = IsotropicElastic(ρ=7800.0, λ=115e9, μ=82e9)\nepoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)\ngeo = Geometry(lat, epoxy, [(Sphere([0,0,0], 0.3), steel)])\n\nsolver = Solver(FullElastic(), geo, (16, 16, 16); cutoff=3)\n\n# Iterative solvers may require shift for 3D\nsolver = Solver(FullElastic(), geo, (16, 16, 16), KrylovKitMethod(shift=0.01); cutoff=3)\nsolver = Solver(FullElastic(), geo, (16, 16, 16), LOBPCGMethod(shift=0.01); cutoff=3)\n\nSee also: SHWave, PSVWave, FullVectorEM\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.AbstractSolver","page":"Solver","title":"PhoXonic.AbstractSolver","text":"AbstractSolver\n\nAbstract base type for all solvers in PhoXonic.jl.\n\nSubtypes:\n\nSolver: Plane wave expansion (PWE) solver\n\nThis abstract type allows for future extensions (e.g., GME solver).\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.Solver","page":"Solver","title":"PhoXonic.Solver","text":"Solver{D<:Dimension, W<:WaveType, M<:SolverMethod} <: AbstractSolver\n\nSolver for computing band structures of photonic/phononic crystals using the plane wave expansion (PWE) method.\n\nFields\n\nwave: Wave type (TE, TM, SH, etc.)\ngeometry: Crystal geometry\nbasis: Plane wave basis\nresolution: Grid resolution for discretization\nmaterial_arrays: Pre-computed material arrays on the grid\nmethod: Solver method (DenseMethod(), BasicRSCG(), etc.)\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.solve","page":"Solver","title":"PhoXonic.solve","text":"solve(solver::Solver, k; bands=1:10)\n\nSolve the eigenvalue problem at wave vector k.\n\nArguments\n\nsolver: The solver\nk: Wave vector (in units of reciprocal lattice vectors or absolute)\nbands: Which bands to return (default: 1:10)\n\nReturns\n\nfrequencies: Eigenfrequencies (sorted, positive)\nmodes: Corresponding eigenvectors\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.solve_at_k","page":"Solver","title":"PhoXonic.solve_at_k","text":"solve_at_k(solver, k, method; bands=1:10, X0=nothing, P=nothing)\n\nSolve eigenvalue problem at a single k-point with explicit control over method, initial vectors, and preconditioner. Returns only frequencies.\n\nFor eigenvectors, use solve_at_k_with_vectors instead.\n\nArguments\n\nsolver::Solver: Solver instance\nk: Wave vector (2D: Vector{Float64}, 1D: Float64)\nmethod::SolverMethod: Solver method (DenseMethod, LOBPCGMethod, etc.)\n\nKeyword Arguments\n\nbands: Range of bands to compute (default: 1:10)\nX0: Initial guess for eigenvectors (default: nothing = auto)\nSize: dim × nev where dim = matrix_dimension(solver) and nev = maximum(bands)\nType: Matrix{ComplexF64}\nIf nothing, random orthonormal vectors are used\nP: Preconditioner (default: nothing = use method's preconditioner setting)\nMust implement ldiv!(y, P, x)\n\nReturns\n\nVector{Float64}: Frequencies for the requested bands\n\nExample\n\nsolver = Solver(PSVWave(), geo, (64, 64); cutoff=20)\ndim = matrix_dimension(solver)  # 2514 for cutoff=20\n\n# Frequencies only\nfreqs = solve_at_k(solver, k, LOBPCGMethod(); bands=1:20)\n\n# With eigenvectors - use solve_at_k_with_vectors\nfreqs, vecs = solve_at_k_with_vectors(solver, k, DenseMethod(); bands=1:20)\n\n# Custom preconditioner\nusing LinearAlgebra\nLHS, _ = build_matrices(solver, k)\nP = Diagonal(1.0 ./ diag(LHS))\nfreqs = solve_at_k(solver, k, LOBPCGMethod(); bands=1:20, P=P)\n\nSee also: solve_at_k_with_vectors, solve, matrix_dimension\n\n\n\n\n\nsolve_at_k(solver, k, method; kwargs...)\n\nSolve eigenvalue problem at a single k-point.\n\nSee concrete method signatures for detailed documentation and keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.solve_at_k_with_vectors","page":"Solver","title":"PhoXonic.solve_at_k_with_vectors","text":"solve_at_k_with_vectors(solver, k, method; bands=1:10, X0=nothing, P=nothing)\n\nSolve eigenvalue problem at a single k-point and return both frequencies and eigenvectors.\n\nThis function always returns eigenvectors, unlike solve_at_k which returns only frequencies by default. Use this when you need the eigenvectors for further analysis (e.g., computing overlaps, mode profiles, or topological invariants).\n\nArguments\n\nsolver::AbstractSolver: The solver object\nk: Wave vector (Real for 1D, AbstractVector for 2D/3D)\nmethod::SolverMethod: Solver method (DenseMethod(), KrylovKitMethod(), LOBPCGMethod())\n\nKeyword Arguments\n\nbands: Range of bands to compute (default: 1:10)\nX0: Initial guess for eigenvectors (for LOBPCG, optional)\nP: Preconditioner (for LOBPCG, optional)\n\nReturns\n\n(frequencies, eigenvectors): Tuple of frequencies (Vector{Float64}) and eigenvectors (Matrix{ComplexF64})\n\nExample\n\nω, vecs = solve_at_k_with_vectors(solver, [0.1, 0.2], DenseMethod(); bands=1:4)\nW = get_weight_matrix(solver)\noverlap = vecs' * W * vecs  # Should be ≈ I (orthonormal)\n\nSee also: solve_at_k, get_weight_matrix, build_matrices\n\n\n\n\n\nsolve_at_k_with_vectors(solver, k, method; kwargs...)\n\nSolve eigenvalue problem and return both frequencies and eigenvectors.\n\nSee concrete method signatures for detailed documentation and keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.build_matrices","page":"Solver","title":"PhoXonic.build_matrices","text":"build_matrices(solver::Solver, k)\n\nBuild the eigenvalue problem matrices LHS * ψ = ω² * RHS * ψ for wave vector k.\n\n\n\n\n\nbuild_matrices(solver::Solver{Dim3, FullVectorEM}, k)\n\nBuild 3N×3N matrices for 3D photonic crystal (H-field formulation).\n\nFormulation: curl × ε⁻¹ × curl H = (ω²/c²) μ H\n\nStorage order: [Hx; Hy; H_z] (component-order for FFT efficiency)\n\n\n\n\n\nbuild_matrices(solver::Solver{Dim3, TransverseEM}, k)\n\nBuild 2N×2N matrices for 3D photonic crystal with transverse projection.\n\nThis is the MPB-compatible formulation that enforces ∇·H = 0 by projecting the 3N×3N FullVectorEM matrices onto the 2N-dimensional transverse subspace.\n\nAlgorithm\n\nBuild 3N×3N matrices (LHS3N, RHS3N) as in FullVectorEM\nConstruct polarization basis P (3N × 2N) where each column is a transverse polarization vector perpendicular to k+G\nProject: LHS = P' * LHS3N * P, RHS = P' * RHS3N * P\n\nAdvantages over FullVectorEM\n\nMatrix size: 2N×2N (vs 3N×3N) → ~2.25× faster solve\nNo spurious longitudinal modes (ω ≈ 0)\nCorrect physical results matching MPB\n\n\n\n\n\nbuild_matrices(solver::Solver{Dim3, FullElastic}, k)\n\nBuild 3N×3N matrices for 3D phononic crystal.\n\nFormulation: -∇·(C:∇u) = ω² ρ u\n\nStorage order: [ux; uy; u_z] (component-order)\n\n\n\n\n\nbuild_matrices(solver, k)\n\nBuild the LHS and RHS matrices for the generalized eigenvalue problem.\n\nSee concrete method signatures for detailed documentation.\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.get_weight_matrix","page":"Solver","title":"PhoXonic.get_weight_matrix","text":"get_weight_matrix(solver::Solver{Dim3, TransverseEM})\n\nNot directly available for TransverseEM due to k-dependency.\n\nThe weight matrix for TransverseEM is the projected μ matrix: W = P' * μ_3N * P, where P is the polarization basis that depends on k. Since this varies with each k-point, a single k-independent weight matrix cannot be provided.\n\nAlternative\n\nUse the RHS matrix returned by build_matrices(solver, k) instead:\n\nLHS, RHS = build_matrices(solver, k)\n# RHS is the 2N×2N projected weight matrix for this k-point\n\nSee also\n\nbuild_matrices: Returns both LHS and RHS (weight) matrices\nsolve_at_k_with_vectors: Returns eigenvectors in the 2N transverse basis\n\n\n\n\n\nget_weight_matrix(solver)\n\nReturn the weight matrix W for computing inner products of eigenvectors.\n\nThe weight matrix satisfies: vecs' * W * vecs ≈ I for orthonormal eigenvectors. This is the RHS matrix of the generalized eigenvalue problem, which defines the inner product in the function space.\n\nSee concrete method signatures for detailed documentation.\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.matrix_dimension","page":"Solver","title":"PhoXonic.matrix_dimension","text":"matrix_dimension(solver::Solver) -> Int\n\nReturn the dimension of the eigenvalue problem matrix.\n\nThis is the size of the matrices A and B in the generalized eigenvalue problem A x = λ B x. Use this to determine the size of initial vectors for iterative solvers like LOBPCG.\n\nReturns\n\nnum_pw for scalar waves (TE, TM, SH, 1D waves)\n2 * num_pw for 2D vector waves (P-SV)\n3 * num_pw for 3D vector waves (FullVectorEM, FullElastic)\n\nExample\n\nsolver = Solver(PSVWave(), geo, (64, 64); cutoff=20)\ndim = matrix_dimension(solver)  # 2 * num_pw\n\n# Create initial vectors for LOBPCG\nX0 = randn(ComplexF64, dim, 20)\nX0, _ = qr(X0)\nX0 = Matrix(X0)\n\n\n\n\n\nmatrix_dimension(solver)\n\nReturn the matrix dimension for the eigenvalue problem.\n\nSee concrete method signatures for detailed documentation.\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.group_velocity","page":"Solver","title":"PhoXonic.group_velocity","text":"group_velocity(solver::Solver, k; bands=1:10, δk=1e-5)\n\nCompute group velocity v_g = ∂ω/∂k at wave vector k.\n\nArguments\n\nsolver: The solver\nk: Wave vector\nbands: Which bands to compute (default: 1:10)\nδk: Finite difference step size (default: 1e-5)\n\nReturns\n\nv_g: Group velocity vectors for each band\n2D: Vector of SVector{2} (vgx, vgy)\n1D: Vector of Float64\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.SolverMethod","page":"Solver","title":"PhoXonic.SolverMethod","text":"SolverMethod\n\nAbstract type for solver methods.\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.IterativeMethod","page":"Solver","title":"PhoXonic.IterativeMethod","text":"IterativeMethod <: SolverMethod\n\nAbstract type for iterative solver methods.\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.RSCGMethod","page":"Solver","title":"PhoXonic.RSCGMethod","text":"RSCGMethod <: IterativeMethod\n\nAbstract type for Reduced Shifted Conjugate Gradient methods. Used for Green's function calculations.\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.DenseMethod","page":"Solver","title":"PhoXonic.DenseMethod","text":"DenseMethod <: SolverMethod\n\nDense matrix eigenvalue solver using LAPACK's eigen function.\n\nThis is the default method, suitable for small to medium-sized systems. It builds the full N×N matrices and computes all eigenvalues/eigenvectors.\n\nFields\n\nshift::Float64: Minimum eigenvalue cutoff (default: 0.0)\nEigenvalues with ω² < shift are filtered out after solving\nUse shift > 0 for 3D FullVectorEM to skip spurious longitudinal modes (λ ≈ 0)\nRecommended: shift = 0.01 for 3D photonic crystals\nNote: Unlike iterative methods, this is post-hoc filtering, not shift-and-invert\n\nComplexity\n\nMemory: O(N²)\nTime: O(N³)\n\nwhere N = numplanewaves × ncomponents(wave)\n\nRecommended For\n\n1D systems (any resolution)\n2D systems with N < ~1000\nDevelopment and debugging (exact results)\n\nExample\n\n# Default (implicit)\nsolver = Solver(TEWave(), geo, (64, 64))\n\n# Explicit\nsolver = Solver(TEWave(), geo, (64, 64), DenseMethod())\n\n# 3D with shift to skip spurious modes\nsolver = Solver(FullVectorEM(), geo, (12, 12, 12), DenseMethod(shift=0.01))\n\nSee also: KrylovKitMethod, LOBPCGMethod\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.BasicRSCG","page":"Solver","title":"PhoXonic.BasicRSCG","text":"BasicRSCG <: RSCGMethod\n\nBasic RSCG method for Green's function computation. Suitable for DOS/LDOS calculations in large systems.\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.KrylovKitMethod","page":"Solver","title":"PhoXonic.KrylovKitMethod","text":"KrylovKitMethod <: IterativeMethod\n\nIterative eigenvalue solver using KrylovKit.jl. Suitable for large systems where dense matrix storage is impractical.\n\nUses shift-and-invert spectral transformation when shift > 0:\n\nOriginal problem: A x = λ B x\nTransformed: (A - σB)⁻¹ B x = μ x where μ = 1/(λ - σ)\n\nThis is particularly useful for 3D calculations where the H-field formulation produces N spurious longitudinal modes with λ ≈ 0. Setting shift > 0 (e.g., 0.01) effectively filters out these unphysical modes and focuses on the transverse (physical) modes.\n\nFields\n\ntol::Float64: Convergence tolerance (default: 1e-8)\nmaxiter::Int: Maximum iterations (default: 300)\nkrylovdim::Int: Krylov subspace dimension (default: 30)\nverbosity::Int: Output verbosity level (0=silent, 1=warn, 2=info)\nshift::Float64: Spectral shift σ for shift-and-invert (default: 0.0)\nshift = 0: Standard generalized eigenvalue problem (no transformation)\nshift > 0: Shift-and-invert, finds eigenvalues closest to σ\nRecommended: shift = 0.01 for 3D photonic crystals to skip longitudinal modes\nmatrix_free::Bool: Use matrix-free operators for shift-and-invert (default: false)\nfalse: Build dense matrices (faster for N < 2000)\ntrue: Use O(N) memory with iterative inner solver (for large 3D problems)\n\nExample\n\n# 2D calculation (no shift needed)\nmethod = KrylovKitMethod()\n\n# 3D calculation (use shift to skip longitudinal modes)\nmethod = KrylovKitMethod(shift=0.01)\n\n# Target specific frequency range\nmethod = KrylovKitMethod(shift=1.5)  # Find modes near ω² = 1.5\n\nSee also: DenseMethod, Solver\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.LOBPCGMethod","page":"Solver","title":"PhoXonic.LOBPCGMethod","text":"LOBPCGMethod <: IterativeMethod\n\nLocally Optimal Block Preconditioned Conjugate Gradient method. Based on Knyazev (2001), SIAM J. Sci. Comput. Vol.23, No.2, pp.517-541.\n\nSolves the symmetric generalized eigenvalue problem A x = λ B x where both A and B are Hermitian and B is positive definite. This method is particularly effective for:\n\nLarge-scale band structure calculations with compute_bands\nPhononic crystal calculations (steel/epoxy, silicon/air, etc.)\n\nWith warm start enabled (default), LOBPCG reuses eigenvectors from previous k-points as initial guesses, achieving significant speedup while maintaining accuracy. The first k-point uses Dense (if first_dense=true) to provide accurate initial eigenvectors.\n\nFields\n\ntol::Float64: Convergence tolerance (default: 1e-3)\nmaxiter::Int: Maximum iterations (default: 100)\nshift::Float64: Spectral shift for shift-and-invert transformation (default: 0.0)\nwarm_start::Bool: Use previous eigenvectors as initial guess (default: true)\nscale::Bool: Scale matrix A by max|A| (default: false, scaling can hurt phononic problems)\nfirst_dense::Bool: Solve first k-point with Dense for accurate warm start (default: true)\npreconditioner: Preconditioner type (default: :none)\n\nNotes\n\nRequires symmetric/Hermitian matrices A and B\nB must be positive definite\nWorks directly with dense matrices (no matrix-free support yet)\nBlock method: computes multiple eigenvalues simultaneously\nFor phononic problems, leave scale=false and preconditioner=:none (defaults)\nWhen shift > 0, uses shift-and-invert to skip eigenvalues near zero (useful for 3D H-field formulation where spurious modes exist at λ ≈ 0)\nNote: With shift > 0, the method falls back to dense eigen solver internally because the shifted matrix (A - σB) is not positive definite as required by LOBPCG.\n\nExample\n\n# Default with warm start (recommended for band structure)\nsolver = Solver(PSVWave(), geo, (64, 64), LOBPCGMethod(); cutoff=20)\n\n# For 3D FullVectorEM (skip spurious modes at λ ≈ 0)\nmethod = LOBPCGMethod(shift=0.01)\n\nSee also: KrylovKitMethod, DenseMethod, matrix_dimension\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.BandStructure","page":"Solver","title":"PhoXonic.BandStructure","text":"BandStructure\n\nResults of a band structure calculation.\n\nFields\n\nkpoints: K-points used (as vector of SVectors)\ndistances: Cumulative distances along the path\nfrequencies: Matrix of frequencies (nk × nbands)\nlabels: High-symmetry point labels (index, label)\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.compute_bands","page":"Solver","title":"PhoXonic.compute_bands","text":"compute_bands(solver::Solver, kpath; bands=1:10, verbose=false)\n\nCompute band structure along a k-point path.\n\nWhen the solver uses LOBPCGMethod with warm_start=true, automatically:\n\nSolves first k-point with Dense (if first_dense=true)\nUses previous eigenvectors as initial guess for subsequent k-points\nApplies matrix scaling (if scale=true)\n\nThis can achieve up to 38x speedup for large problems.\n\nArguments\n\nsolver: The solver\nkpath: K-point path (SimpleKPath, KPathInterpolant, or Vector)\nbands: Which bands to compute (default: 1:10)\nverbose: Print progress (default: false)\n\nReturns\n\nA BandStructure object containing frequencies for each k-point and band.\n\n\n\n\n\ncompute_bands(solver::Solver, kpoints::Vector; bands=1:10)\n\nCompute band structure at specified k-points (without path structure).\n\n\n\n\n\ncompute_bands(solver::Solver, kpi::KPathInterpolant; bands=1:10, verbose=false)\n\nCompute band structure using Brillouin.jl KPathInterpolant.\n\n\n\n\n\ncompute_bands(solver::Solver{Dim3}, kpath::SimpleKPath{3}; bands=1:10, verbose=false)\n\nCompute 3D band structure along a k-point path.\n\nArguments\n\nsolver: 3D solver (FullVectorEM or FullElastic)\nkpath: K-point path from simple_kpath_cubic, simple_kpath_fcc, etc.\nbands: Which bands to compute (default: 1:10)\nverbose: Print progress (default: false)\n\nReturns\n\nA BandStructure{3} object containing frequencies for each k-point and band.\n\nExample\n\nlat = fcc_lattice(1.0)\ngeo = Geometry(lat, Dielectric(1.0), [(Sphere([0,0,0], 0.25), Dielectric(12.0))])\nsolver = Solver(FullVectorEM(), geo, (12,12,12), KrylovKitMethod(shift=0.01); cutoff=3)\nkpath = simple_kpath_fcc(a=1.0, npoints=20)\nbands = compute_bands(solver, kpath; bands=1:6)\n\nNote\n\nAt Γ point (k=0), the lowest transverse modes also have ω→0, which can cause anomalous values. Consider using a small k offset or skipping the Γ point.\n\n\n\n\n\ncompute_bands(solver::Solver{Dim3}, kpoints::Vector; bands=1:10, verbose=false)\n\nCompute 3D band structure at specified k-points (without path structure).\n\nArguments\n\nsolver: 3D solver (FullVectorEM or FullElastic)\nkpoints: Vector of k-points as 3-element vectors\nbands: Which bands to compute (default: 1:10)\nverbose: Print progress (default: false)\n\nReturns\n\nA BandStructure{3} object. Labels will be empty since no path structure is provided.\n\nExample\n\nkpoints = [[0.5, 0.0, 0.0], [0.5, 0.5, 0.0], [0.5, 0.5, 0.5]]\nbands = compute_bands(solver, kpoints; bands=1:6)\n\n\n\n\n\ncompute_bands(solver::Solver{Dim3}, kpi::KPathInterpolant; bands=1:10, verbose=false)\n\nCompute 3D band structure using Brillouin.jl KPathInterpolant.\n\nArguments\n\nsolver: 3D solver (FullVectorEM or FullElastic)\nkpi: K-path interpolant from kpath_cubic, kpath_fcc, kpath_bcc, etc.\nbands: Which bands to compute (default: 1:10)\nverbose: Print progress (default: false)\n\nReturns\n\nA BandStructure{3} object.\n\nExample\n\nlat = cubic_lattice(1.0)\ngeo = Geometry(lat, Dielectric(1.0), [(Sphere([0,0,0], 0.3), Dielectric(12.0))])\nsolver = Solver(FullVectorEM(), geo, (12,12,12), KrylovKitMethod(shift=0.01); cutoff=3)\nkpath = kpath_cubic(a=1.0, N=50)  # Brillouin.jl based\nbands = compute_bands(solver, kpath; bands=1:6)\n\n\n\n\n\ncompute_bands(solver, kpath; kwargs...)\n\nCompute band structure along a k-path.\n\nSee concrete method signatures for detailed documentation and keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.find_bandgap","page":"Solver","title":"PhoXonic.find_bandgap","text":"find_bandgap(bs::BandStructure, band1::Int, band2::Int)\n\nFind the band gap between band1 and band2.\n\nReturns\n\nNamed tuple with:\n\ngap: Band gap width (0 if bands overlap)\ngap_ratio: Gap-to-midgap ratio\nmin_upper: Minimum of upper band\nmax_lower: Maximum of lower band\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.find_all_gaps","page":"Solver","title":"PhoXonic.find_all_gaps","text":"find_all_gaps(bs::BandStructure; threshold=0.0)\n\nFind all band gaps in the band structure.\n\nReturns\n\nVector of named tuples with gap information.\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.frequencies","page":"Solver","title":"PhoXonic.frequencies","text":"frequencies(bs::BandStructure)\n\nReturn the frequency matrix.\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.distances","page":"Solver","title":"PhoXonic.distances","text":"distances(bs::BandStructure)\n\nReturn the cumulative distances along the k-path.\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.labels","page":"Solver","title":"PhoXonic.labels","text":"labels(bs::BandStructure)\n\nReturn the high-symmetry point labels.\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.nbands","page":"Solver","title":"PhoXonic.nbands","text":"nbands(bs::BandStructure)\n\nReturn the number of bands.\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.nkpoints","page":"Solver","title":"PhoXonic.nkpoints","text":"nkpoints(bs::BandStructure)\n\nReturn the number of k-points.\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.SimpleKPath","page":"Solver","title":"PhoXonic.SimpleKPath","text":"SimpleKPath{D}\n\nA simple k-path structure for basic band structure calculations. Use this when Brillouin.jl's full functionality is not needed.\n\n\n\n\n\n","category":"type"},{"location":"api-solver/#PhoXonic.simple_kpath_square","page":"Solver","title":"PhoXonic.simple_kpath_square","text":"simple_kpath_square(; a=1.0, npoints=50)\n\nCreate a simple k-path for square lattice without Brillouin.jl. Γ → X → M → Γ\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.simple_kpath_hexagonal","page":"Solver","title":"PhoXonic.simple_kpath_hexagonal","text":"simple_kpath_hexagonal(; a=1.0, npoints=50)\n\nCreate a simple k-path for hexagonal lattice without Brillouin.jl. Γ → M → K → Γ\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.simple_kpath_cubic","page":"Solver","title":"PhoXonic.simple_kpath_cubic","text":"simple_kpath_cubic(; a=1.0, npoints=50)\n\nCreate a simple k-path for simple cubic (SC) lattice.\n\nPath: Γ → X → M → Γ → R → X\n\nHigh-symmetry points (in units of 2π/a):\n\nΓ = (0, 0, 0)\nX = (1/2, 0, 0)\nM = (1/2, 1/2, 0)\nR = (1/2, 1/2, 1/2)\n\nArguments\n\na: Lattice constant (default: 1.0)\nnpoints: Number of points per segment (default: 50)\n\nReturns\n\nA SimpleKPath{3} object that can be passed to compute_bands.\n\nExample\n\nlat = cubic_lattice(1.0)\ngeo = Geometry(lat, Dielectric(1.0), [(Sphere([0,0,0], 0.3), Dielectric(12.0))])\nsolver = Solver(FullVectorEM(), geo, (12,12,12), KrylovKitMethod(shift=0.01); cutoff=3)\nkpath = simple_kpath_cubic(a=1.0, npoints=30)\nbands = compute_bands(solver, kpath; bands=1:6)\n\nSee also: kpath_cubic for Brillouin.jl-based k-path, Brillouin.jl documentation\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.simple_kpath_fcc","page":"Solver","title":"PhoXonic.simple_kpath_fcc","text":"simple_kpath_fcc(; a=1.0, npoints=50)\n\nCreate a simple k-path for face-centered cubic (FCC) lattice.\n\nPath: Γ → X → W → L → Γ → K\n\nHigh-symmetry points (values shown are multiplied by 2π/a to give Cartesian coordinates):\n\nΓ = (0, 0, 0)\nX = (0, 1, 0) × 2π/a\nW = (1/2, 1, 0) × 2π/a\nL = (1/2, 1/2, 1/2) × 2π/a\nK = (3/4, 3/4, 0) × 2π/a\n\nArguments\n\na: Conventional lattice constant (default: 1.0)\nnpoints: Number of points per segment (default: 50)\n\nReturns\n\nA SimpleKPath{3} object that can be passed to compute_bands.\n\nExample\n\nlat = fcc_lattice(1.0)\ngeo = Geometry(lat, Dielectric(1.0), [(Sphere([0,0,0], 0.25), Dielectric(12.0))])\nsolver = Solver(FullVectorEM(), geo, (12,12,12), KrylovKitMethod(shift=0.01); cutoff=3)\nkpath = simple_kpath_fcc(a=1.0, npoints=30)\nbands = compute_bands(solver, kpath; bands=1:6)\n\nSee also: kpath_fcc for Brillouin.jl-based k-path, Brillouin.jl documentation\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.simple_kpath_bcc","page":"Solver","title":"PhoXonic.simple_kpath_bcc","text":"simple_kpath_bcc(; a=1.0, npoints=50)\n\nCreate a simple k-path for body-centered cubic (BCC) lattice.\n\nPath: Γ → H → N → Γ → P → H\n\nHigh-symmetry points (values shown are multiplied by 2π/a to give Cartesian coordinates):\n\nΓ = (0, 0, 0)\nH = (0, 0, 1) × 2π/a\nN = (0, 1/2, 1/2) × 2π/a\nP = (1/4, 1/4, 1/4) × 2π/a\n\nArguments\n\na: Conventional lattice constant (default: 1.0)\nnpoints: Number of points per segment (default: 50)\n\nReturns\n\nA SimpleKPath{3} object that can be passed to compute_bands.\n\nExample\n\nkpath = simple_kpath_bcc(a=1.0, npoints=30)\nbands = compute_bands(solver, kpath; bands=1:6)\n\nSee also: kpath_bcc for Brillouin.jl-based k-path, Brillouin.jl documentation\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.kpath_from_brillouin","page":"Solver","title":"PhoXonic.kpath_from_brillouin","text":"kpath_from_brillouin(sgnum::Int, Rs; N=100)\n\nCreate a k-path using Brillouin.jl's irrfbz_path.\n\nArguments\n\nsgnum: Space group number (e.g., 1 for P1, 227 for diamond)\nRs: Direct lattice vectors as a matrix or vector of vectors\nN: Number of interpolation points (default: 100)\n\nReturns\n\nA KPathInterpolant that can be iterated over.\n\nExample\n\n# Square lattice (space group 1, primitive cell)\nRs = [[1.0, 0.0], [0.0, 1.0]]\nkpi = kpath_from_brillouin(1, Rs; N=100)\n\n# Iterate over k-points\nfor k in kpi\n    # k is an SVector\nend\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.kpath_square","page":"Solver","title":"PhoXonic.kpath_square","text":"kpath_square(; a=1.0, N=100)\n\nCreate a standard k-path for a 2D square lattice: Γ → X → M → Γ\n\nUses Brillouin.jl with space group 1 (P1).\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.kpath_hexagonal","page":"Solver","title":"PhoXonic.kpath_hexagonal","text":"kpath_hexagonal(; a=1.0, N=100)\n\nCreate a standard k-path for a 2D hexagonal lattice: Γ → M → K → Γ\n\nUses Brillouin.jl with appropriate space group.\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.kpath_cubic","page":"Solver","title":"PhoXonic.kpath_cubic","text":"kpath_cubic(; a=1.0, N=100)\n\nCreate a k-path for simple cubic (SC) lattice using Brillouin.jl.\n\nPath: Γ → X → M → Γ → R → X | R → M\n\nUses space group 221 (Pm-3m).\n\nArguments\n\na: Lattice constant (default: 1.0)\nN: Number of interpolation points (default: 100)\n\nReturns\n\nA KPathInterpolant from Brillouin.jl that can be passed to compute_bands.\n\nExample\n\nlat = cubic_lattice(1.0)\ngeo = Geometry(lat, Dielectric(1.0), [(Sphere([0,0,0], 0.3), Dielectric(12.0))])\nsolver = Solver(FullVectorEM(), geo, (12,12,12), KrylovKitMethod(shift=0.01); cutoff=3)\nkpath = kpath_cubic(a=1.0, N=100)\nbands = compute_bands(solver, kpath; bands=1:6)\n\nReference: Setyawan & Curtarolo, Comp. Mat. Sci. 49, 299 (2010). DOI:10.1016/j.commatsci.2010.05.010\n\nSee also: Brillouin.jl irrfbz_path\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.kpath_fcc","page":"Solver","title":"PhoXonic.kpath_fcc","text":"kpath_fcc(; a=1.0, N=100)\n\nCreate a k-path for face-centered cubic (FCC) lattice using Brillouin.jl.\n\nPath: Γ → X → U | K → Γ → L → W → X\n\nUses space group 225 (Fm-3m).\n\nArguments\n\na: Conventional lattice constant (default: 1.0)\nN: Number of interpolation points (default: 100)\n\nReturns\n\nA KPathInterpolant from Brillouin.jl that can be passed to compute_bands.\n\nExample\n\nlat = fcc_lattice(1.0)\ngeo = Geometry(lat, Dielectric(1.0), [(Sphere([0,0,0], 0.25), Dielectric(12.0))])\nsolver = Solver(FullVectorEM(), geo, (12,12,12), KrylovKitMethod(shift=0.01); cutoff=3)\nkpath = kpath_fcc(a=1.0, N=100)\nbands = compute_bands(solver, kpath; bands=1:6)\n\nReference: Setyawan & Curtarolo, Comp. Mat. Sci. 49, 299 (2010). DOI:10.1016/j.commatsci.2010.05.010\n\nSee also: Brillouin.jl irrfbz_path\n\n\n\n\n\n","category":"function"},{"location":"api-solver/#PhoXonic.kpath_bcc","page":"Solver","title":"PhoXonic.kpath_bcc","text":"kpath_bcc(; a=1.0, N=100)\n\nCreate a k-path for body-centered cubic (BCC) lattice using Brillouin.jl.\n\nPath: Γ → H → N → Γ → P → H | P → N\n\nUses space group 229 (Im-3m).\n\nArguments\n\na: Conventional lattice constant (default: 1.0)\nN: Number of interpolation points (default: 100)\n\nReturns\n\nA KPathInterpolant from Brillouin.jl that can be passed to compute_bands.\n\nExample\n\nkpath = kpath_bcc(a=1.0, N=100)\nbands = compute_bands(solver, kpath; bands=1:6)\n\nReference: Setyawan & Curtarolo, Comp. Mat. Sci. 49, 299 (2010). DOI:10.1016/j.commatsci.2010.05.010\n\nSee also: Brillouin.jl irrfbz_path\n\n\n\n\n\n","category":"function"},{"location":"analysis/#Analysis-and-Post-Processing","page":"Analysis","title":"Analysis and Post-Processing","text":"","category":"section"},{"location":"analysis/#Convergence-Check","page":"Analysis","title":"Convergence Check","text":"for res in [32, 64, 128]\n    solver = Solver(TMWave(), geo, (res, res); cutoff=7)\n    bands = compute_bands(solver, kpath; bands=1:4)\n    gap = find_bandgap(bands, 1, 2)\n    println(\"Resolution $res: gap = $(gap.gap)\")\nend","category":"section"},{"location":"analysis/#Group-Velocity","page":"Analysis","title":"Group Velocity","text":"k = [0.5, 0.0]  # Point in BZ\nvg = group_velocity(solver, k; bands=1:4)\n# vg[i] = [∂ω/∂kx, ∂ω/∂ky] for band i","category":"section"},{"location":"analysis/#K-path-Options","page":"Analysis","title":"K-path Options","text":"","category":"section"},{"location":"analysis/#Simple-k-paths","page":"Analysis","title":"Simple k-paths","text":"kpath = simple_kpath_square(a=1.0, npoints=30)    # Γ-X-M-Γ\nkpath = simple_kpath_hexagonal(a=1.0, npoints=30) # Γ-M-K-Γ","category":"section"},{"location":"analysis/#[Brillouin.jl](https://thchr.github.io/Brillouin.jl/stable/)-integration","page":"Analysis","title":"Brillouin.jl integration","text":"using Brillouin\n\n# Automatic high-symmetry path\nkpi = irrfbz_path(2, lat.vectors)\nkpath = kpath_from_brillouin(kpi, npoints=100)","category":"section"},{"location":"analysis/#Plotting","page":"Analysis","title":"Plotting","text":"Requires Plots.jl:\n\nusing Plots\nplot_bands(bands)","category":"section"},{"location":"analysis/#Saving-and-Loading-Results","page":"Analysis","title":"Saving and Loading Results","text":"PhoXonic.jl uses JLD2.jl for saving and loading results.","category":"section"},{"location":"analysis/#Bands","page":"Analysis","title":"Bands","text":"# Save\nbands = compute_bands(solver, kpath)\nsave_bands(\"bands.jld2\", bands)\n\n# Load\nbands_loaded = load_bands(\"bands.jld2\")","category":"section"},{"location":"analysis/#Eigenmodes","page":"Analysis","title":"Eigenmodes","text":"# Save with optional k-point and frequencies\nω, modes = solve(solver, k; bands=1:5)\nsave_modes(\"modes.jld2\", modes; k=k, frequencies=ω)\n\n# Load\ndata = load_modes(\"modes.jld2\")\n# data.modes, data.k, data.frequencies","category":"section"},{"location":"analysis/#Material-Arrays","page":"Analysis","title":"Material Arrays","text":"# Photonic: saves ε, ε⁻¹, μ\nsave_epsilon(\"epsilon.jld2\", solver)\n\n# Phononic: saves C11, C12, C44, ρ\nsave_epsilon(\"elastic.jld2\", solver_phononic)\n\n# Load\neps = load_epsilon(\"epsilon.jld2\")\n# eps.ε, eps.resolution, eps.wave_type","category":"section"},{"location":"analysis/#File-Contents","page":"Analysis","title":"File Contents","text":"Function Saved Data\nsave_bands frequencies, kpoints, distances, labels, metadata\nsave_modes modes, k (optional), frequencies (optional), metadata\nsave_epsilon Material arrays depend on wave type (see above)","category":"section"},{"location":"analysis/#API-Reference","page":"Analysis","title":"API Reference","text":"Solver API - BandStructure, findbandgap, groupvelocity\nPlotting API - plot_bands (requires Plots.jl)\nI/O API - save/load functions (requires JLD2.jl)","category":"section"},{"location":"api-advanced/#Advanced-API","page":"Advanced","title":"Advanced API","text":"","category":"section"},{"location":"api-advanced/#Matrix-Free-Operators","page":"Advanced","title":"Matrix-Free Operators","text":"","category":"section"},{"location":"api-advanced/#Effective-Hamiltonian","page":"Advanced","title":"Effective Hamiltonian","text":"","category":"section"},{"location":"api-advanced/#Green's-Function-and-DOS/LDOS","page":"Advanced","title":"Green's Function and DOS/LDOS","text":"note: Optional Dependency\nRSKGF and MatrixFreeGF methods require using ReducedShiftedKrylov. See Green's Function Methods for detailed usage.","category":"section"},{"location":"api-advanced/#Unified-API","page":"Advanced","title":"Unified API","text":"","category":"section"},{"location":"api-advanced/#RHS-Inversion-Methods","page":"Advanced","title":"RHS Inversion Methods","text":"","category":"section"},{"location":"api-advanced/#High-Level-Functions","page":"Advanced","title":"High-Level Functions","text":"","category":"section"},{"location":"api-advanced/#Stochastic-DOS","page":"Advanced","title":"Stochastic DOS","text":"","category":"section"},{"location":"api-advanced/#PhoXonic.FFTContext","page":"Advanced","title":"PhoXonic.FFTContext","text":"FFTContext{N, T<:Complex, F, I}\n\nThread-safe container for FFT plans. Plans can be shared across threads since fftw_execute is thread-safe. Create once and reuse.\n\nFields\n\nresolution: Grid resolution tuple\nfft_plan: Pre-computed forward FFT plan\nifft_plan: Pre-computed inverse FFT plan\n\n\n\n\n\n","category":"type"},{"location":"api-advanced/#PhoXonic.MatrixFreeWorkspace","page":"Advanced","title":"PhoXonic.MatrixFreeWorkspace","text":"MatrixFreeWorkspace{N, T<:Complex}\n\nThread-local workspace arrays for matrix-free operations. Each thread should have its own workspace instance.\n\nFields\n\nwork_real: Workspace array in real space\nwork_fourier: Workspace array in Fourier space\n\n\n\n\n\n","category":"type"},{"location":"api-advanced/#PhoXonic.MatrixFreeOperator","page":"Advanced","title":"PhoXonic.MatrixFreeOperator","text":"MatrixFreeOperator{D<:Dimension, W<:WaveType, T<:Complex}\n\nMatrix-free representation of the Hamiltonian operator H = RHS⁻¹ * LHS.\n\nFields\n\nsolver: Reference to the solver (contains geometry, basis, material_arrays)\nk: Current wave vector\nctx: FFT context (shared, thread-safe for execution)\nworkspace: Work arrays (thread-local)\n\nThread Safety\n\nThe FFT plans in ctx can be safely shared across threads. However, each thread must have its own workspace to avoid data races. For parallel k-point loops:\n\nctx = FFTContext(solver)  # Create once\nThreads.@threads for k in k_points\n    ws = MatrixFreeWorkspace(ctx)  # One per thread\n    op = MatrixFreeOperator(solver, k, ctx, ws)\n    # ... use op ...\nend\n\nGrid Resolution Constraint\n\nImportant: The solver's grid resolution must be large enough to contain all plane wave indices. The required resolution in each dimension is:\n\nresolution >= 2 * cutoff + 1\n\nFor example, with cutoff=7 (default), the resolution must be at least 15 in each dimension (e.g., 16×16 for 2D, 16×16×16 for 3D).\n\nIf the resolution is too small, plane wave coefficients outside the grid range will be silently dropped during FFT operations, leading to incorrect results.\n\n\n\n\n\n","category":"type"},{"location":"api-advanced/#PhoXonic.apply_lhs!","page":"Advanced","title":"PhoXonic.apply_lhs!","text":"apply_lhs!(y, op::MatrixFreeOperator, x)\n\nApply LHS operator: y = LHS * x For TE: LHS = Kx * ε⁻¹ * Kx + Ky * ε⁻¹ * Ky\n\n\n\n\n\napply_lhs!(y, op::MatrixFreeOperator{Dim1}, x)\n\nApply LHS operator for 1D: y = K * ε⁻¹ * K * x\n\n\n\n\n\n","category":"function"},{"location":"api-advanced/#PhoXonic.apply_rhs!","page":"Advanced","title":"PhoXonic.apply_rhs!","text":"apply_rhs!(y, op::MatrixFreeOperator, x)\n\nApply RHS operator: y = RHS * x\n\n\n\n\n\n","category":"function"},{"location":"api-advanced/#PhoXonic.to_linear_map_lhs","page":"Advanced","title":"PhoXonic.to_linear_map_lhs","text":"to_linear_map(op::MatrixFreeOperator)\n\nConvert MatrixFreeOperator to a LinearMap for use with iterative solvers. Returns LHS as a LinearMap.\n\n\n\n\n\n","category":"function"},{"location":"api-advanced/#PhoXonic.to_linear_map_rhs","page":"Advanced","title":"PhoXonic.to_linear_map_rhs","text":"to_linear_map_rhs(op::MatrixFreeOperator)\n\nConvert RHS to a LinearMap.\n\n\n\n\n\n","category":"function"},{"location":"api-advanced/#PhoXonic.EffectiveHamiltonian","page":"Advanced","title":"PhoXonic.EffectiveHamiltonian","text":"EffectiveHamiltonian{TL, TR, TF}\n\nEffective Hamiltonian operator H = RHS⁻¹ * LHS for use with Krylov.jl.\n\nTransforms the generalized eigenvalue problem:     LHS * ψ = ω² * RHS * ψ into the standard form:     H * ψ = ω² * ψ\n\nFor Green's function computation:     G(z) = (z·I - H)⁻¹ = (z·I - RHS⁻¹·LHS)⁻¹\n\nFields\n\nLHS: Left-hand side matrix\nRHS: Right-hand side matrix\nRHS_factorization: LU factorization of RHS for efficient solves\nn: Problem dimension\ntmp: Temporary vector for intermediate computations\n\nUsage with Krylov.jl\n\nUse NegatedOperator(H) to get -H, then solve (σI + A)x = b where A = -H.\n\n\n\n\n\n","category":"type"},{"location":"api-advanced/#PhoXonic.MatrixFreeEffectiveHamiltonian","page":"Advanced","title":"PhoXonic.MatrixFreeEffectiveHamiltonian","text":"MatrixFreeEffectiveHamiltonian{D, W, T}\n\nMatrix-free effective Hamiltonian operator H = RHS⁻¹ * LHS.\n\nThis is the fully matrix-free version of EffectiveHamiltonian, using O(N) memory instead of O(N²) for dense matrices.\n\nFor photonic crystals:\n\nTE: RHS = μ, so RHS⁻¹ = 1/μ (element-wise in real space)\nTM: RHS = ε, so RHS⁻¹ = 1/ε (element-wise in real space)\n\nFor phononic crystals:\n\nSH/PSV: RHS = ρ, so RHS⁻¹ = 1/ρ (element-wise in real space)\n\nGrid Resolution Constraint\n\nImportant: The solver's grid resolution must be large enough to contain all plane wave indices. The required resolution in each dimension is:\n\nresolution >= 2 * max_index + 1\n\nwhere max_index is the maximum absolute value of plane wave indices (typically equal to the cutoff parameter). For example, with cutoff=7 (indices -7 to 7), the resolution must be at least 15 in each dimension.\n\nIf the resolution is too small, Fourier coefficients outside the grid will be silently dropped, leading to incorrect results (errors can be ~100%).\n\nUsage\n\nop = MatrixFreeOperator(solver, k)\nH = MatrixFreeEffectiveHamiltonian(op)\nA = NegatedOperator(H)  # A = -H for RSCG\nx, stats = rscg(A, b, shifts)\n\nRHS⁻¹ methods\n\n:approximate: Element-wise 1/ε in real space (fast, approximate for inhomogeneous media)\n:cg: Iterative CG to solve RHS * y = x (slower, exact)\n\n\n\n\n\n","category":"type"},{"location":"api-advanced/#PhoXonic.NegatedOperator","page":"Advanced","title":"PhoXonic.NegatedOperator","text":"NegatedOperator{T}\n\nWrapper that negates an operator: A = -H.\n\nThis transforms the Green's function problem:     G(z) = (z·I - H)⁻¹  →  solve (z·I + A)x = b where A = -H\n\nKrylov.jl's cg_lanczos_shift solves (A + σI)x = b, so we use:     A = -H, σ = z  →  (z·I - H)x = b\n\nUsage\n\nH = EffectiveHamiltonian(LHS, RHS)\nA = NegatedOperator(H)\n# Now use A with Krylov.cg_lanczos_shift\n\n\n\n\n\n","category":"type"},{"location":"api-advanced/#PhoXonic.GFMethod","page":"Advanced","title":"PhoXonic.GFMethod","text":"GFMethod\n\nAbstract type for Green's function computation methods. Used by compute_greens_function, compute_dos, and compute_ldos.\n\n\n\n\n\n","category":"type"},{"location":"api-advanced/#PhoXonic.DirectGF","page":"Advanced","title":"PhoXonic.DirectGF","text":"DirectGF()\n\nDense direct solve method (LU factorization). Most accurate but O(N²) memory and O(N³) per frequency.\n\n\n\n\n\n","category":"type"},{"location":"api-advanced/#PhoXonic.RSKGF","page":"Advanced","title":"PhoXonic.RSKGF","text":"RSKGF(; atol=1e-10, rtol=1e-10, itmax=0, verbose=0)\n\nDense RSK method using ReducedShiftedKrylov.jl. O(N²) memory, efficient for many frequencies.\n\n\n\n\n\n","category":"type"},{"location":"api-advanced/#PhoXonic.MatrixFreeGF","page":"Advanced","title":"PhoXonic.MatrixFreeGF","text":"MatrixFreeGF(; rhs_inv_method=:approximate, atol=1e-10, rtol=1e-10, itmax=0, verbose=0)\n\nMatrix-free RSCG method. O(N) memory, O(N log N) per iteration.\n\nArguments\n\nrhs_inv_method: Method for RHS⁻¹ application\n:approximate: Element-wise 1/ε (fast, approximate for inhomogeneous media)\n:cg: Iterative CG (slower, exact)\n\nRecommended Usage\n\nPeak/resonance detection: accurate even without full RSCG convergence\nLarge-scale calculations where Dense methods are memory-prohibitive\nFor accurate absolute values, use DirectGF() instead\n\n\n\n\n\n","category":"type"},{"location":"api-advanced/#PhoXonic.RHSInvMethod","page":"Advanced","title":"PhoXonic.RHSInvMethod","text":"RHSInvMethod\n\nAbstract type for RHS⁻¹ application methods in matrix-free effective Hamiltonian.\n\nConcrete subtypes:\n\nApproximateRHSInv: Fast element-wise 1/ε in real space (approximate)\nCGRHSInv: Iterative CG to solve RHS * y = x (exact)\n\nSee also: MatrixFreeEffectiveHamiltonian, MatrixFreeGF\n\n\n\n\n\n","category":"type"},{"location":"api-advanced/#PhoXonic.ApproximateRHSInv","page":"Advanced","title":"PhoXonic.ApproximateRHSInv","text":"ApproximateRHSInv <: RHSInvMethod\n\nApproximate method for RHS⁻¹ application: element-wise 1/ε (or 1/ρ) in real space.\n\nFast but inaccurate for high-contrast media (e.g., Si/Air with ε ratio ≈ 12:1).\n\nExample\n\nmethod = MatrixFreeGF(rhs_inv_method=ApproximateRHSInv())\n\n\n\n\n\n","category":"type"},{"location":"api-advanced/#PhoXonic.CGRHSInv","page":"Advanced","title":"PhoXonic.CGRHSInv","text":"CGRHSInv <: RHSInvMethod\n\nCG-based method for RHS⁻¹ application: solve RHS * y = x iteratively.\n\nAccurate but slower than approximate method. Recommended for high-contrast media.\n\nFields\n\natol::Float64: Absolute tolerance (default: 1e-10)\nrtol::Float64: Relative tolerance (default: 1e-10)\nmaxiter::Int: Maximum iterations (default: 100)\n\nExample\n\n# Default parameters\nmethod = MatrixFreeGF(rhs_inv_method=CGRHSInv())\n\n# Custom parameters for high-contrast media\nmethod = MatrixFreeGF(rhs_inv_method=CGRHSInv(atol=1e-12, rtol=1e-12, maxiter=200))\n\n\n\n\n\n","category":"type"},{"location":"api-advanced/#PhoXonic.compute_greens_function","page":"Advanced","title":"PhoXonic.compute_greens_function","text":"compute_greens_function(solver::Solver, k, ω_values, source; η=1e-3)\n\nCompute Green's function G(ω) = (ω² + iη - H)⁻¹ * source for multiple frequencies.\n\nUses direct solve (dense method). For large systems, use matrix-free iterative methods.\n\nArguments\n\nsolver: The PhoXonic solver\nk: Wave vector\nω_values: Frequencies at which to compute G\nsource: Source vector in plane wave basis\nη: Broadening parameter (small positive imaginary part)\n\nReturns\n\nVector of Green's function values G(ω) * source for each ω\n\n\n\n\n\ncompute_greens_function(solver, k, ω_values, source, method::GFMethod; η=1e-3)\n\nCompute Green's function G(ω) * source using the specified method.\n\nMethods\n\nDirectGF(): Dense direct solve (most accurate, O(N²) memory)\nRSKGF(): Dense RSK using ReducedShiftedKrylov.jl\nMatrixFreeGF(): Matrix-free RSCG (O(N) memory, best for large systems)\n\nExamples\n\n# Direct solve (default)\nG = compute_greens_function(solver, k, ω_values, source; η=1e-2)\n\n# Matrix-free for large systems\nG = compute_greens_function(solver, k, ω_values, source, MatrixFreeGF(); η=1e-2)\n\n\n\n\n\n","category":"function"},{"location":"api-advanced/#PhoXonic.compute_dos","page":"Advanced","title":"PhoXonic.compute_dos","text":"compute_dos(solver::Solver, ω_values, k_points; η=1e-3)\n\nCompute density of states (DOS) by summing over k-points.\n\nDOS(ω) = -1/π Im[Tr G(ω)] summed over k-points\n\nArguments\n\nsolver: The PhoXonic solver\nω_values: Frequencies at which to compute DOS\nk_points: List of k-points to sum over (should cover Brillouin zone)\nη: Broadening parameter\n\nReturns\n\nVector of DOS values at each frequency\n\n\n\n\n\ncompute_dos(solver, ω_values, k_points, method::GFMethod; η=1e-3, n_random=10)\n\nCompute density of states (DOS) using the specified method.\n\nMethods\n\nDirectGF(): Dense direct solve (most accurate)\nRSKGF(): Dense RSK with stochastic trace estimation\nMatrixFreeGF(): Matrix-free RSCG with stochastic trace estimation\n\nExamples\n\n# Direct solve (default)\ndos = compute_dos(solver, ω_values, k_points; η=1e-2)\n\n# Matrix-free for large systems\ndos = compute_dos(solver, ω_values, k_points, MatrixFreeGF(); η=1e-2)\n\n\n\n\n\n","category":"function"},{"location":"api-advanced/#PhoXonic.compute_ldos","page":"Advanced","title":"PhoXonic.compute_ldos","text":"compute_ldos(solver::Solver, position, ω_values, k_points; η=1e-3)\n\nCompute local density of states (LDOS) at a given position.\n\nLDOS(r, ω) = -1/π Im[G(r, r, ω)]\n\nArguments\n\nsolver: The PhoXonic solver\nposition: Position in real space (Vec2 or [x, y])\nω_values: Frequencies at which to compute LDOS\nk_points: List of k-points to sum over\nη: Broadening parameter\n\nReturns\n\nVector of LDOS values at each frequency\n\n\n\n\n\ncompute_ldos(solver, position, ω_values, k_points, method::GFMethod; η=1e-3)\n\nCompute local density of states (LDOS) using the specified method.\n\nMethods\n\nDirectGF(): Dense direct solve (most accurate, O(N²) memory)\nRSKGF(): Dense RSK using ReducedShiftedKrylov.jl\nMatrixFreeGF(): Matrix-free RSCG (O(N) memory, best for large systems)\n\nExamples\n\n# Direct solve (default when method not specified)\nldos = compute_ldos(solver, pos, ω_values, k_points; η=1e-2)\n\n# Matrix-free for large systems\nldos = compute_ldos(solver, pos, ω_values, k_points, MatrixFreeGF(); η=1e-2)\n\n# Matrix-free with exact RHS⁻¹\nldos = compute_ldos(solver, pos, ω_values, k_points, MatrixFreeGF(rhs_inv_method=:cg); η=1e-2)\n\n# Dense RSK\nldos = compute_ldos(solver, pos, ω_values, k_points, RSKGF(); η=1e-2)\n\nSee Also\n\ncompute_dos: Compute density of states (trace of Green's function)\ncompute_greens_function: Compute Green's function directly\n\n\n\n\n\n","category":"function"},{"location":"api-advanced/#PhoXonic.compute_dos_stochastic","page":"Advanced","title":"PhoXonic.compute_dos_stochastic","text":"compute_dos_stochastic(solver::Solver, ω_values, k_points; η=1e-3, n_random=10)\n\nCompute DOS using stochastic trace estimation.\n\nThis approximates Tr[G] by averaging over random vectors:     Tr[G] ≈ (1/nrandom) Σi <vi | G | vi>\n\nMore efficient than exact trace for large systems.\n\nArguments\n\nsolver: The PhoXonic solver\nω_values: Frequencies at which to compute DOS\nk_points: List of k-points\nη: Broadening parameter\nn_random: Number of random vectors for stochastic averaging\n\n\n\n\n\n","category":"function"},{"location":"matrixfree/#Matrix-Free-Methods","page":"Matrix-Free Methods","title":"Matrix-Free Methods","text":"PhoXonic.jl provides matrix-free implementations for large-scale calculations where storing dense matrices is prohibitive.","category":"section"},{"location":"matrixfree/#Overview","page":"Matrix-Free Methods","title":"Overview","text":"","category":"section"},{"location":"matrixfree/#Memory-and-Computational-Complexity","page":"Matrix-Free Methods","title":"Memory and Computational Complexity","text":"Operation Dense Matrix-Free\nMemory O(N²) O(N)\nMatrix construction O(N³) O(N)\nMatrix-vector product O(N²) O(N log N)\n\nFor a 3D calculation with N = 10,000 plane waves and 3 components:\n\nDense: ~14 GB for matrices\nMatrix-free: ~few MB","category":"section"},{"location":"matrixfree/#Supported-Wave-Types","page":"Matrix-Free Methods","title":"Supported Wave Types","text":"Wave Type Dimension LHS FFTs RHS FFTs\nTEWave 2D 4 2\nTMWave 2D 4 2\nSHWave 2D 4 2\nPSVWave 2D 16 4\nPhotonic1D 1D 2 2\nLongitudinal1D 1D 2 2\nFullVectorEM 3D 24 6\nFullElastic 3D 42 6","category":"section"},{"location":"matrixfree/#Grid-Resolution-Constraint","page":"Matrix-Free Methods","title":"Grid Resolution Constraint","text":"warning: Important\nThe solver's grid resolution must be large enough to contain all plane wave indices.\n\nThe required resolution in each dimension is:\n\nresolution >= 2 * cutoff + 1\n\nCutoff Min Resolution Recommended\n7 (default) 15 16 or 32\n10 21 32\n15 31 32","category":"section"},{"location":"matrixfree/#Dense-vs-Matrix-Free-Equivalence","page":"Matrix-Free Methods","title":"Dense vs Matrix-Free Equivalence","text":"When the resolution constraint is satisfied, matrix-free and dense methods produce mathematically identical results (up to floating-point rounding errors ~10⁻¹⁵).\n\nDense method (convolution matrix):\n\nM[i,j] = ε̃(Gᵢ - Gⱼ)\ny = M * x                    # O(N²) matrix-vector product\n\nMatrix-free method (FFT-based):\n\ny = FFT{ ε(r) · iFFT{x} }    # O(N log N) via FFT\n\nBy the convolution theorem of discrete FFT, both compute the same cyclic convolution.","category":"section"},{"location":"matrixfree/#Why-Aliasing-Occurs","page":"Matrix-Free Methods","title":"Why Aliasing Occurs","text":"When the grid is too small, aliasing corrupts the results:\n\ncutoff=7 → plane wave indices: -7 to +7\n\nWith resolution 16×16:\n  - Grid can hold indices -8 to +7\n  - Problem: multiplying two plane waves extends the range\n    Example: G=5 × G=5 → needs G=10, but grid can only hold up to G=7\n  - High-frequency components wrap around (cyclic convolution artifact)\n  - Result: ~4% error\n\nWith resolution 32×32:\n  - Grid can hold indices -16 to +15\n  - Sufficient margin for all products of plane waves\n  - Result: ~10⁻¹⁶ error (machine precision)","category":"section"},{"location":"matrixfree/#Example:-Correct-vs-Incorrect-Resolution","page":"Matrix-Free Methods","title":"Example: Correct vs Incorrect Resolution","text":"# Incorrect: resolution too small for cutoff=7\nsolver_bad = Solver(TEWave(), geo, (8, 8); cutoff=7)  # Error ~96%\n\n# Correct: resolution >= 2*7+1 = 15\nsolver_good = Solver(TEWave(), geo, (16, 16); cutoff=7)  # Error ~10⁻¹⁶\nsolver_good = Solver(TEWave(), geo, (32, 32); cutoff=7)  # Also correct","category":"section"},{"location":"matrixfree/#Usage-with-Iterative-Eigensolvers","page":"Matrix-Free Methods","title":"Usage with Iterative Eigensolvers","text":"See also: examples/208_solver_comparison.jl - Dense vs LOBPCG performance comparison\n\nMatrix-free operators are used automatically with iterative solvers:\n\nusing PhoXonic\n\n# Create geometry\nlat = square_lattice(1.0)\nmat_rod = Dielectric(8.9)\nmat_air = Dielectric(1.0)\nrod = Circle([0.5, 0.5], 0.2)\ngeo = Geometry(lat, mat_air, [(rod, mat_rod)])\n\n# Use resolution >= 2*cutoff+1\nsolver = Solver(TEWave(), geo, (32, 32), KrylovKitMethod(); cutoff=7)\n\n# Solve - uses matrix-free internally\nk = [0.5, 0.0]\nω, modes = solve(solver, k; bands=1:5)\n\nFor 3D calculations with matrix-free methods, FullVectorEM with shift-and-invert is used:\n\nlat = cubic_lattice(1.0)\ngeo = Geometry(lat, Dielectric(1.0), [(Sphere([0.5,0.5,0.5], 0.3), Dielectric(12.0))])\n\n# Resolution must be >= 2*cutoff+1 in each dimension\nsolver = Solver(FullVectorEM(), geo, (16, 16, 16), KrylovKitMethod(shift=0.01); cutoff=7)\nω, modes = solve(solver, [0.1, 0.1, 0.1]; bands=1:6)\n\nNote: For most 3D photonic crystal calculations, TransverseEM with DenseMethod() is recommended as it eliminates spurious modes without requiring shift-and-invert. See 3D Calculations for details.","category":"section"},{"location":"matrixfree/#Unified-Green's-Function-API","page":"Matrix-Free Methods","title":"Unified Green's Function API","text":"See also: examples_rsk/502_defect_mode_matrixfree.jl - Matrix-free LDOS calculation (requires ReducedShiftedKrylov.jl)\n\nPhoXonic provides a unified API for Green's function, DOS, and LDOS calculations. The same GFMethod types work with all three functions.\n\nFor detailed documentation on DOS/LDOS functions, see DOS / LDOS.","category":"section"},{"location":"matrixfree/#Available-Methods","page":"Matrix-Free Methods","title":"Available Methods","text":"Method Memory Description\nDirectGF() O(N²) LU factorization, most accurate\nRSKGF() O(N²) ReducedShiftedKrylov.jl\nMatrixFreeGF() O(N) Matrix-free RSCG, best for large systems","category":"section"},{"location":"matrixfree/#Basic-Usage","page":"Matrix-Free Methods","title":"Basic Usage","text":"using PhoXonic\n\nsolver = Solver(TEWave(), geo, (32, 32); cutoff=7)\nk = [0.5, 0.0]\nω_values = [0.3, 0.4, 0.5, 0.6]\nk_points = [[0.0, 0.0], [0.5, 0.0], [0.5, 0.5]]\n\n# Default (DirectGF) - no method argument needed\nG = compute_greens_function(solver, k, ω_values, source; η=1e-2)\ndos = compute_dos(solver, ω_values, k_points; η=1e-2)\nldos = compute_ldos(solver, [0.5, 0.5], ω_values, k_points; η=1e-2)\n\n# With explicit method\nG = compute_greens_function(solver, k, ω_values, source, DirectGF(); η=1e-2)\ndos = compute_dos(solver, ω_values, k_points, MatrixFreeGF(); η=1e-2)\nldos = compute_ldos(solver, [0.5, 0.5], ω_values, k_points, RSKGF(); η=1e-2)","category":"section"},{"location":"matrixfree/#MatrixFreeGF-Options","page":"Matrix-Free Methods","title":"MatrixFreeGF Options","text":"MatrixFreeGF has an rhs_inv_method option for RHS⁻¹ application:\n\nOption Description Speed Accuracy\nApproximateRHSInv() Element-wise 1/ε (default) Fast Approximate for inhomogeneous media\nCGRHSInv() Inner CG iteration Slower Exact\n\n# Fast approximate method (default)\nldos = compute_ldos(solver, pos, ω_values, k_points, MatrixFreeGF(); η=1e-2)\n\n# Exact CG method\nldos = compute_ldos(solver, pos, ω_values, k_points, MatrixFreeGF(rhs_inv_method=CGRHSInv()); η=1e-2)\n\n# CGRHSInv with custom parameters\nldos = compute_ldos(solver, pos, ω_values, k_points,\n    MatrixFreeGF(rhs_inv_method=CGRHSInv(atol=1e-12, rtol=1e-12, maxiter=200)); η=1e-2)\n\nnote: When to use CGRHSInv\nApproximateRHSInv() is sufficient for most cases, especially for peak detection\nUse CGRHSInv() when accurate absolute values are needed for high-contrast structures\n\nwarning: RSCG Convergence\nThe RSCG solver may not fully converge for all problems. This affects RSKGF and MatrixFreeGF equally.Symptoms of incomplete convergence:Relative errors of a few percent compared to direct solveMitigation strategies:Increase itmax parameter\nUse smaller η (broadening) values\nFor critical applications, use DirectGF()\n\ntip: Practical Usage\nMatrixFreeGF() is recommended for:Peak/resonance frequency detection (accurate even without full convergence)\nLarge-scale calculations where Dense methods are memory-prohibitive\nQualitative spectral analysisDirectGF() is recommended for:Accurate absolute LDOS/DOS values\nQuantitative analysis requiring high precision\nSmaller systems where O(N²) memory is acceptable","category":"section"},{"location":"matrixfree/#Method-Comparison","page":"Matrix-Free Methods","title":"Method Comparison","text":"# Direct solve - O(N²) memory, O(N³) per frequency\nG_direct = compute_greens_function(solver, k, ω_values, source, DirectGF(); η=1e-2)\n\n# Dense RSK - O(N²) memory, efficient for many frequencies\nG_rsk = compute_greens_function(solver, k, ω_values, source, RSKGF(); η=1e-2)\n\n# Matrix-free - O(N) memory, O(N log N) per iteration\nG_mf = compute_greens_function(solver, k, ω_values, source, MatrixFreeGF(); η=1e-2)\n\n# Matrix-free with exact RHS⁻¹\nG_mf_cg = compute_greens_function(solver, k, ω_values, source, MatrixFreeGF(rhs_inv_method=CGRHSInv()); η=1e-2)","category":"section"},{"location":"matrixfree/#Low-Level-API","page":"Matrix-Free Methods","title":"Low-Level API","text":"","category":"section"},{"location":"matrixfree/#[FFTContext](api-advanced.md#PhoXonic.FFTContext)-and-[MatrixFreeWorkspace](api-advanced.md#PhoXonic.MatrixFreeWorkspace)","page":"Matrix-Free Methods","title":"FFTContext and MatrixFreeWorkspace","text":"For optimal performance in loops, separate FFT plan creation from workspace allocation:\n\n# FFTContext: holds FFT plans (create once, reuse)\nctx = FFTContext(solver)\n\n# MatrixFreeWorkspace: holds work arrays (one per thread)\nworkspace = MatrixFreeWorkspace(ctx)\n\n# Create operator with explicit context and workspace\nop = MatrixFreeOperator(solver, k, ctx, workspace)\n\nwarning: Thread Safety\nFFT plan creation is NOT thread-safe (FFTW.jl limitation). Create FFTContext from a single thread before entering parallel regions.FFT plan execution IS thread-safe. The same FFTContext can be shared across threads, but each thread must have its own MatrixFreeWorkspace to avoid data races.","category":"section"},{"location":"matrixfree/#[MatrixFreeOperator](api-advanced.md#PhoXonic.MatrixFreeOperator)","page":"Matrix-Free Methods","title":"MatrixFreeOperator","text":"# Simple usage (creates new FFT plans internally)\nop = MatrixFreeOperator(solver, k)\n\n# Optimized usage (reuse FFT plans)\nctx = FFTContext(solver)\nworkspace = MatrixFreeWorkspace(ctx)\nop = MatrixFreeOperator(solver, k, ctx, workspace)\n\n# Apply LHS: y = LHS * x\ny = zeros(ComplexF64, N)\napply_lhs!(y, op, x)\n\n# Apply RHS: y = RHS * x\napply_rhs!(y, op, x)","category":"section"},{"location":"matrixfree/#[MatrixFreeEffectiveHamiltonian](api-advanced.md#PhoXonic.MatrixFreeEffectiveHamiltonian)","page":"Matrix-Free Methods","title":"MatrixFreeEffectiveHamiltonian","text":"For RSCG integration:\n\n# Create effective Hamiltonian H = RHS⁻¹ * LHS\nop = MatrixFreeOperator(solver, k)\nH = MatrixFreeEffectiveHamiltonian(op)\n\n# Negate for RSCG: A = -H\nA = NegatedOperator(H)\n\n# Solve (σI + A)x = b for multiple shifts\nshifts = [ω^2 + im*η for ω in ω_values]\nx_solutions, stats = ReducedShiftedKrylov.rscg(A, b, shifts)","category":"section"},{"location":"matrixfree/#LinearMap-Interface","page":"Matrix-Free Methods","title":"LinearMap Interface","text":"using LinearMaps  # https://julialinearalgebra.github.io/LinearMaps.jl/stable/\n\n# Convert to LinearMap for use with other iterative solvers\nA_lhs = to_linear_map_lhs(op)  # LHS as LinearMap\nB_rhs = to_linear_map_rhs(op)  # RHS as LinearMap","category":"section"},{"location":"matrixfree/#Performance-Tips","page":"Matrix-Free Methods","title":"Performance Tips","text":"Choose resolution wisely: Use resolution = 2^n for optimal FFT performance (e.g., 16, 32, 64 instead of 15, 31, 63).\nReuse FFT plans: Use FFTContext and MatrixFreeWorkspace to avoid recreating FFT plans in loops:\nctx = FFTContext(solver)           # Create once (not thread-safe)\nworkspace = MatrixFreeWorkspace(ctx)  # One per thread\n\nfor k in k_points\n    op = MatrixFreeOperator(solver, k, ctx, workspace)\n    # ... use op ...\nend\nThread safety: FFT plan execution is thread-safe, but creation is not. For parallel k-point loops:\nctx = FFTContext(solver)  # Create once in main thread\nThreads.@threads for k in k_points\n    ws = MatrixFreeWorkspace(ctx)  # Each thread needs its own workspace\n    op = MatrixFreeOperator(solver, k, ctx, ws)\n    # ... use op ...\nend\n3D calculations: Matrix-free is essential for 3D. Dense matrices for N = 10,000 require ~14 GB, while matrix-free uses only a few MB.\nRSCG convergence: Matrix-free RSCG often converges better than dense RSCG due to better numerical conditioning.","category":"section"},{"location":"matrixfree/#API-Reference","page":"Matrix-Free Methods","title":"API Reference","text":"Advanced API - MatrixFreeOperator, FFTContext, EffectiveHamiltonian","category":"section"},{"location":"solver/#Solver-Methods","page":"Solver Methods","title":"Solver Methods","text":"PhoXonic.jl provides multiple solver methods for different problem sizes:\n\nMethod Matrix Storage Algorithm Best For\nDenseMethod() Dense (N×N) LAPACK eigen Small/medium systems\nDenseMethod(shift=σ) Dense (N×N) LAPACK eigen + filter 3D (skip spurious modes)\nKrylovKitMethod() Matrix-free Arnoldi iteration Large 2D systems\nKrylovKitMethod(shift=σ) Dense + LU Shift-and-invert 3D, targeted frequencies\nLOBPCGMethod() Dense (N×N) Block CG Symmetric problems\nLOBPCGMethod(shift=σ) Dense + LU Shift-and-invert LOBPCG 3D systems","category":"section"},{"location":"solver/#Memory-and-Computational-Cost","page":"Solver Methods","title":"Memory and Computational Cost","text":"Method Memory Cost per k-point\nDense O(N²) O(N³) eigendecomposition\nMatrix-free O(N) O(N log N) × iterations\nShift-invert O(N²) O(N³) LU + O(N²) × iterations\nLOBPCG O(N²) O(N² × nev) × iterations\n\nN = number of plane waves = basis.num_pw × ncomponents(wave)\n\nFor large-scale calculations with N > 10,000, see Matrix-Free Methods.","category":"section"},{"location":"solver/#Recommendations","page":"Solver Methods","title":"Recommendations","text":"Dimension Wave Type N (typical) Recommended Method Example\n1D Photonic1D < 100 DenseMethod() 301\n1D Longitudinal1D < 100 DenseMethod() 302\n2D TEWave/TMWave/SHWave 100–1,000 DenseMethod() 101, 201\n2D TE/TM/SH 1,000–10,000 KrylovKitMethod() or LOBPCGMethod() 201, 208\n2D PSVWave 200–2,000 DenseMethod() 201\n2D PSVWave > 2,000 KrylovKitMethod() or LOBPCGMethod() 201, 208\n3D TransverseEM < 2,000 DenseMethod() (recommended) 401\n3D FullVectorEM < 500 DenseMethod(shift=0.01) 402\n3D FullVectorEM 500–5,000 KrylovKitMethod(shift=0.01) or LOBPCGMethod(shift=0.01) —\n3D FullElastic < 500 DenseMethod(shift=0.01) —\n3D FullElastic 500–5,000 KrylovKitMethod(shift=0.01) or LOBPCGMethod(shift=0.01) —\n\nNote: For 3D photonic crystals, TransverseEM is strongly recommended over FullVectorEM. See TransverseEM vs FullVectorEM for why.\n\nNote: For 3D phononic crystals, FullElastic is an experimental implementation. See FullElastic (Experimental) for why parameter tuning is challenging.","category":"section"},{"location":"solver/#DenseMethod","page":"Solver Methods","title":"DenseMethod","text":"The default solver using LAPACK's dense eigenvalue decomposition.","category":"section"},{"location":"solver/#Basic-Usage","page":"Solver Methods","title":"Basic Usage","text":"solver = Solver(TEWave(), geo, (64, 64), DenseMethod(); cutoff=7)","category":"section"},{"location":"solver/#DenseMethod-for-3D","page":"Solver Methods","title":"DenseMethod for 3D","text":"For small 3D systems, DenseMethod with shift > 0 can be used:\n\nsolver = Solver(FullVectorEM(), geo, (12, 12, 12), DenseMethod(shift=0.01); cutoff=5)  # Use cutoff≥7 for high ε\n\nHow it works:\n\nUnlike iterative methods which use shift-and-invert transformation, DenseMethod(shift=σ) computes all eigenvalues using LAPACK, then filters out eigenvalues where ω² < σ. This post-hoc filtering effectively removes the spurious longitudinal modes at ω ≈ 0.\n\nImportant difference from iterative methods:\n\nAspect DenseMethod KrylovKitMethod/LOBPCGMethod\nComputation All eigenvalues Only requested number\nFiltering Post-hoc (ω² < σ removed) Shift-and-invert (finds λ closest to σ)\nBand ordering Strictly ascending ω Depends on σ proximity\nMemory O(N²) O(N²) with shift, O(N) without\n\nThis means Dense and iterative methods may return different bands for the same bands=1:n request if there are intermediate eigenvalues. Both results are valid eigenvalues, just in different order.\n\nWhen to use DenseMethod for 3D:\n\nSmall systems (N × 3 < 2000)\nValidation and debugging\nNeed all eigenvalues in ascending order","category":"section"},{"location":"solver/#KrylovKitMethod","page":"Solver Methods","title":"KrylovKitMethod","text":"Iterative solver based on KrylovKit.jl using Arnoldi iteration.","category":"section"},{"location":"solver/#Basic-Usage-2","page":"Solver Methods","title":"Basic Usage","text":"solver = Solver(TEWave(), geo, (128, 128), KrylovKitMethod(); cutoff=15)","category":"section"},{"location":"solver/#Shift-and-Invert-for-3D","page":"Solver Methods","title":"Shift-and-Invert for 3D","text":"For 3D calculations, use shift-and-invert to skip longitudinal modes:\n\nsolver = Solver(FullVectorEM(), geo, (16, 16, 16), KrylovKitMethod(shift=0.01); cutoff=7)\n\nThe shift parameter σ transforms the generalized eigenvalue problem:\n\nOriginal Transformed\nA x = λ B x (A - σB)⁻¹ B x = μ x\nλ = eigenvalue μ = 1/(λ - σ)\n\nEigenvalues closest to σ become the largest |μ|, making them easiest for iterative solvers to find.","category":"section"},{"location":"solver/#Why-is-Shift-Needed-for-3D?","page":"Solver Methods","title":"Why is Shift Needed for 3D?","text":"The 3D H-field formulation does not explicitly enforce ∇·H = 0, producing:\n\nLongitudinal modes: λ ≈ 0 (unphysical, violate transversality)\nTransverse modes: λ > 0 (physical electromagnetic waves)\n\nWithout shift, iterative solvers converge to the spurious λ ≈ 0 modes first. With shift σ > 0, eigenvalues λ < σ are effectively filtered out.","category":"section"},{"location":"solver/#Choosing-σ","page":"Solver Methods","title":"Choosing σ","text":"Use case Recommended σ Explanation\nSkip longitudinal modes 0.001 – 0.1 Must be > 0, but smaller than the smallest physical λ\nTarget specific frequency ω²_target Finds modes near the target frequency first\nLow-frequency modes near k |k|²/ε_max Approximate lowest transverse eigenvalue\n\nGuidelines for choosing σ:\n\nLower bound: σ must be larger than the longitudinal mode eigenvalues (≈ 0). A small positive value like σ = 0.01 typically works.\nUpper bound: σ should be smaller than the smallest physical eigenvalue you want to find. For a homogeneous medium: λmin ≈ |k|²/εmax.\nExample: |k| = 0.5, ε = 4 → λ_min ≈ 0.0625. Use σ < 0.06.\nSafe default: For most 3D photonic calculations, σ = 0.01 works well when |k| ≥ 0.1 (in units of 2π/a).\nNear k = 0: At the Γ point (k = 0), the lowest transverse modes also have λ → 0. Use a very small shift (σ ~ 0.001) or skip the Γ point.\nHigh-contrast materials: For large ε, eigenvalues scale as 1/ε. Reduce σ proportionally: σ ≈ 0.01 / ε_max.","category":"section"},{"location":"solver/#Troubleshooting","page":"Solver Methods","title":"Troubleshooting","text":"Symptom Likely cause Solution\nAll eigenvalues ≈ 0 σ too large Reduce σ\nMissing low-frequency modes σ too large Reduce σ below λ_min\nConverges to spurious modes σ too small or = 0 Increase σ > 0\nSlow convergence σ far from target λ Adjust σ closer to desired eigenvalues","category":"section"},{"location":"solver/#Phononic-Eigenvalue-Scaling","page":"Solver Methods","title":"Phononic Eigenvalue Scaling","text":"Phononic eigenvalues ω² are typically O(10¹⁰) for common materials (steel, epoxy, etc.), which can cause numerical instability in iterative solvers. PhoXonic.jl automatically scales the eigenvalue problem for SHWave, PSVWave, FullElastic, and Longitudinal1D:\n\nScaled problem: (A/s) x = (λ/s) B x\nwhere s = c² × |k|² and c² = C₁₁/ρ (longitudinal wave speed squared)\n\nThis normalizes eigenvalues to O(1), ensuring stable convergence. The scaling is:\n\nAutomatic: No user configuration needed\nTransparent: Results are unscaled before return\nPhotonic-safe: Scale factor = 1.0 for TE/TM/FullVectorEM\n\nExample: Steel/epoxy at |k| = 100 rad/m:\n\nWithout scaling: ω² ~ 10¹⁰ → KrylovKit may fail\nWith scaling: ω²/s ~ 1 → stable convergence","category":"section"},{"location":"solver/#KrylovKitMethod-Parameters","page":"Solver Methods","title":"KrylovKitMethod Parameters","text":"method = KrylovKitMethod(\n    tol = 1e-8,       # Convergence tolerance\n    maxiter = 300,    # Maximum iterations\n    krylovdim = 30,   # Krylov subspace dimension\n    verbosity = 0,    # 0=silent, 1=warnings, 2=info\n    shift = 0.0,      # Spectral shift (0 = no shift)\n    matrix_free = false  # Use matrix-free operators for shift-and-invert\n)","category":"section"},{"location":"solver/#Matrix-Free-Shift-and-Invert","page":"Solver Methods","title":"Matrix-Free Shift-and-Invert","text":"For large 3D calculations where memory is limited, the matrix_free=true option avoids building dense matrices:\n\n# Memory-efficient for large 3D systems\nsolver = Solver(\n    FullVectorEM(), geo, (32, 32, 32),\n    KrylovKitMethod(shift=0.01, matrix_free=true);\n    cutoff=5\n)\n\nComparison:\n\nAspect matrix_free=false (default) matrix_free=true\nMemory O(N²) O(N)\nSpeed Faster for N < 2000 Slower (nested iteration)\nBest for Small/medium 3D Large 3D (N > 2000)\n\nHow it works:\n\nDefault mode: Builds dense matrices LHS, RHS, computes LU factorization of (A - σB)\nMatrix-free mode: Uses FFT-based operators and iterative CG solver for inner system\n\nFor most 3D calculations with cutoff ≤ 5, the default dense mode is faster. Use matrix_free=true when memory becomes the limiting factor.","category":"section"},{"location":"solver/#LOBPCGMethod","page":"Solver Methods","title":"LOBPCGMethod","text":"LOBPCG (Locally Optimal Block Preconditioned Conjugate Gradient) is an iterative eigenvalue solver. A. V. Knyazev, SIAM J. Sci. Comput. 23, 517 (2001). DOI:10.1137/S1064827500366124","category":"section"},{"location":"solver/#When-to-Use-LOBPCG","page":"Solver Methods","title":"When to Use LOBPCG","text":"LOBPCG is effective for:\n\nLarge-scale band structure calculations (cutoff ≥ 12)\nSymmetric generalized eigenvalue problems A x = λ B x\nComputing multiple eigenvalues simultaneously (block method)\n\nPerformance comparison (2D PSV wave, Steel/Epoxy):\n\nCutoff Matrix Size Dense LOBPCG Speedup Error\n8 394 4.4 s 11.8 s 0.37x* 8.5 rad/s\n10 634 10.1 s 12.8 s 0.79x* 16.2 rad/s\n12 882 21.5 s 19.8 s 1.09x 15.8 rad/s\n15 1418 105.3 s 50.4 s 2.09x 30.2 rad/s\n\n*Speedup < 1 means Dense is faster\n\nRecommendation:\n\ncutoff < 10: Use Dense (faster due to BLAS optimization)\ncutoff ≥ 12: Use LOBPCG (speedup increases with problem size)","category":"section"},{"location":"solver/#Basic-Usage-3","page":"Solver Methods","title":"Basic Usage","text":"# 2D photonic\nsolver = Solver(TEWave(), geo, (64, 64), LOBPCGMethod(); cutoff=12)\n\n# 2D phononic (LOBPCG effective for large problems)\nsolver = Solver(PSVWave(), geo, (64, 64), LOBPCGMethod(); cutoff=15)","category":"section"},{"location":"solver/#Shift-and-Invert-for-3D-2","page":"Solver Methods","title":"Shift-and-Invert for 3D","text":"For 3D calculations, LOBPCG requires shift > 0 to skip spurious longitudinal modes:\n\nsolver = Solver(FullVectorEM(), geo, (16, 16, 16), LOBPCGMethod(shift=0.01); cutoff=7)\n\nsolver = Solver(FullElastic(), geo, (16, 16, 16), LOBPCGMethod(shift=0.01); cutoff=5)\n\nWhy is shift needed for 3D?\n\nThe 3D H-field formulation does not enforce the transversality constraint ∇·H = 0, leading to spurious longitudinal modes at λ ≈ 0. Without shift:\n\nLOBPCG tries to find smallest eigenvalues, converging to these spurious modes\nThe RHS matrix B becomes singular in this subspace → PosDefException\n\nWith shift=σ, the problem transforms to (A - σB)⁻¹ B x = μ x, which only returns eigenvalues λ > σ, effectively filtering out the spurious modes.","category":"section"},{"location":"solver/#LOBPCGMethod-Parameters","page":"Solver Methods","title":"LOBPCGMethod Parameters","text":"method = LOBPCGMethod(\n    tol = 1e-3,              # Convergence tolerance (default)\n    maxiter = 100,           # Maximum iterations (default)\n    shift = 0.0,             # Spectral shift (required for 3D)\n    warm_start = true,       # Use previous eigenvectors as initial guess\n    first_dense = true,      # Solve first k-point with Dense\n)","category":"section"},{"location":"solver/#Warm-Start-for-Band-Structure-Calculations","page":"Solver Methods","title":"Warm Start for Band Structure Calculations","text":"When computing band structures with compute_bands, LOBPCG uses warm start to speed up calculations. The eigenvectors from the previous k-point serve as the initial guess for the next k-point.\n\nHow it works:\n\nFirst k-point is solved with DenseMethod (when first_dense=true)\nSubsequent k-points use previous eigenvectors as initial guess\nSince eigenvectors vary smoothly along k-path, LOBPCG converges quickly\n\nUsage:\n\n# Automatic warm start (default)\nsolver = Solver(PSVWave(), geo, (64, 64), LOBPCGMethod(); cutoff=15)\nbands = compute_bands(solver, kpath; bands=1:10)","category":"section"},{"location":"solver/#Limitations","page":"Solver Methods","title":"Limitations","text":"For small problems (cutoff < 10), Dense is faster due to BLAS optimization\nPhononic problems with band crossings at Γ point may require additional care\nAccuracy is typically 10-100 rad/s compared to Dense (0.1-1% relative error)","category":"section"},{"location":"solver/#LOBPCG-vs-KrylovKit","page":"Solver Methods","title":"LOBPCG vs KrylovKit","text":"Feature KrylovKitMethod LOBPCGMethod\nBackend KrylovKit.jl IterativeSolvers.jl\nAlgorithm Arnoldi (Krylov) Block CG\nMatrix-free Yes (2D/3D) No\nPhononic scaling Required Not required\nBlock computation No Yes\n3D shift-invert Yes Yes\n\nFor details on matrix-free methods and their resolution constraints, see Matrix-Free Methods.","category":"section"},{"location":"solver/#API-Reference","page":"Solver Methods","title":"API Reference","text":"Solver API - DenseMethod, KrylovKitMethod, LOBPCGMethod","category":"section"},{"location":"api/#Core-API","page":"Core","title":"Core API","text":"","category":"section"},{"location":"api/#Dimensions","page":"Core","title":"Dimensions","text":"","category":"section"},{"location":"api/#Lattice","page":"Core","title":"Lattice","text":"","category":"section"},{"location":"api/#Materials","page":"Core","title":"Materials","text":"","category":"section"},{"location":"api/#Shapes","page":"Core","title":"Shapes","text":"","category":"section"},{"location":"api/#Geometry","page":"Core","title":"Geometry","text":"","category":"section"},{"location":"api/#Plane-Wave-Basis","page":"Core","title":"Plane Wave Basis","text":"\n\nSee also:\n\nSolver API - Wave types, Solver, Band structure\nAdvanced API - Matrix-free, Green's function\nPlotting API (requires Plots.jl)\nI/O API (requires JLD2.jl)","category":"section"},{"location":"api/#PhoXonic.Dim1","page":"Core","title":"PhoXonic.Dim1","text":"Dim1\n\nOne-dimensional structures (e.g., Bragg mirrors, superlattices).\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.Dim2","page":"Core","title":"PhoXonic.Dim2","text":"Dim2\n\nTwo-dimensional structures (e.g., photonic crystal slabs, 2D phononic crystals).\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.Dim3","page":"Core","title":"PhoXonic.Dim3","text":"Dim3\n\nThree-dimensional structures (e.g., 3D photonic crystals, bulk phononic crystals).\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.Lattice","page":"Core","title":"PhoXonic.Lattice","text":"Lattice{D<:Dimension}\n\nRepresents a periodic lattice in D dimensions.\n\nFields\n\nvectors: Primitive lattice vectors as a tuple of SVectors\nreciprocal: Reciprocal lattice vectors (computed automatically)\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.lattice_1d","page":"Core","title":"PhoXonic.lattice_1d","text":"lattice_1d(a::Real=1.0)\n\nCreate a 1D periodic lattice with period a.\n\n\n\n\n\n","category":"function"},{"location":"api/#PhoXonic.square_lattice","page":"Core","title":"PhoXonic.square_lattice","text":"square_lattice(a::Real=1.0)\n\nCreate a 2D square lattice with lattice constant a.\n\n\n\n\n\n","category":"function"},{"location":"api/#PhoXonic.hexagonal_lattice","page":"Core","title":"PhoXonic.hexagonal_lattice","text":"hexagonal_lattice(a::Real=1.0)\n\nCreate a 2D hexagonal (triangular) lattice with lattice constant a.\n\n\n\n\n\n","category":"function"},{"location":"api/#PhoXonic.cubic_lattice","page":"Core","title":"PhoXonic.cubic_lattice","text":"cubic_lattice(a::Real=1.0)\n\nCreate a 3D simple cubic lattice with lattice constant a.\n\n\n\n\n\n","category":"function"},{"location":"api/#PhoXonic.fcc_lattice","page":"Core","title":"PhoXonic.fcc_lattice","text":"fcc_lattice(a::Real=1.0)\n\nCreate a 3D face-centered cubic lattice with conventional lattice constant a.\n\n\n\n\n\n","category":"function"},{"location":"api/#PhoXonic.reciprocal_vectors","page":"Core","title":"PhoXonic.reciprocal_vectors","text":"reciprocal_vectors(lattice::Lattice)\n\nReturn the reciprocal lattice vectors.\n\n\n\n\n\n","category":"function"},{"location":"api/#PhoXonic.Dielectric","page":"Core","title":"PhoXonic.Dielectric","text":"Dielectric(ε, μ=1.0)\n\nIsotropic dielectric material with permittivity ε and permeability μ.\n\nExamples\n\nair = Dielectric(1.0)\nsilicon = Dielectric(11.7)\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.IsotropicElastic","page":"Core","title":"PhoXonic.IsotropicElastic","text":"IsotropicElastic(ρ, C11, C12, C44)\n\nIsotropic elastic material with density ρ and elastic constants.\n\nFor isotropic materials: C44 = (C11 - C12) / 2\n\nFields\n\nρ: Mass density [kg/m³]\nC11: Elastic constant (λ + 2μ) [Pa]\nC12: Elastic constant (λ) [Pa]\nC44: Shear modulus (μ) [Pa]\n\nExamples\n\n# Steel\nsteel = IsotropicElastic(7800.0, 282e9, 113e9, 84.5e9)\n\n# From Lamé parameters\nepoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.from_E_ν","page":"Core","title":"PhoXonic.from_E_ν","text":"from_E_ν(ρ, E, ν)\n\nCreate isotropic elastic material from Young's modulus E and Poisson's ratio ν.\n\n\n\n\n\n","category":"function"},{"location":"api/#PhoXonic.Circle","page":"Core","title":"PhoXonic.Circle","text":"Circle(center, radius)\n\nA circle in 2D.\n\nExamples\n\nc = Circle(Vec2(0, 0), 0.2)\nc = Circle([0.0, 0.0], 0.2)\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.Rectangle","page":"Core","title":"PhoXonic.Rectangle","text":"Rectangle(center, size)\n\nAn axis-aligned rectangle in 2D.\n\nExamples\n\nr = Rectangle(Vec2(0, 0), Vec2(0.5, 0.3))\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.Polygon","page":"Core","title":"PhoXonic.Polygon","text":"Polygon(vertices)\n\nA polygon in 2D defined by its vertices (in order).\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.Sphere","page":"Core","title":"PhoXonic.Sphere","text":"Sphere(center, radius)\n\nA sphere in 3D.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.Cylinder","page":"Core","title":"PhoXonic.Cylinder","text":"Cylinder(center, radius, height, axis)\n\nA cylinder in 3D with specified center, radius, height, and axis direction. Default axis is along z.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.Segment","page":"Core","title":"PhoXonic.Segment","text":"Segment(start, stop)\n\nA line segment in 1D.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.Geometry","page":"Core","title":"PhoXonic.Geometry","text":"Geometry{D<:Dimension, M<:Material}\n\nRepresents the geometry of a periodic crystal structure.\n\nFields\n\nlattice: The periodic lattice\nbackground: Background material\ninclusions: List of (shape, material) pairs\n\nExamples\n\nlattice = square_lattice(1.0)\nair = Dielectric(1.0)\nrod = Dielectric(8.9)\ngeo = Geometry(lattice, air, [(Circle(Vec2(0,0), 0.2), rod)])\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.discretize","page":"Core","title":"PhoXonic.discretize","text":"discretize(geo::Geometry{Dim2}, resolution, property, [method])\n\nDiscretize a 2D geometry onto a grid.\n\nArguments\n\ngeo: The geometry to discretize\nresolution: Tuple (Nx, Ny) of grid points\nproperty: Property to extract (:ε, :μ, :ρ, :C11, :C12, :C44)\nmethod: Discretization method (default: SimpleGrid())\n\nReturns\n\nA matrix of property values on the grid.\n\n\n\n\n\ndiscretize(geo::Geometry{Dim1}, resolution, property, [method])\n\nDiscretize a 1D geometry onto a grid.\n\n\n\n\n\ndiscretize(geo::Geometry{Dim3}, resolution, property, [method])\n\nDiscretize a 3D geometry onto a grid.\n\nArguments\n\ngeo: The 3D geometry to discretize\nresolution: Tuple (Nx, Ny, Nz) of grid points\nproperty: Property to extract (:ε, :μ, :ρ, :C11, :C12, :C44, etc.)\nmethod: Discretization method (default: SimpleGrid())\n\nReturns\n\nA 3D array of property values on the grid.\n\n\n\n\n\ndiscretize(geometry, resolution, ...)\n\nDiscretize geometry on a grid.\n\nSee concrete method signatures for detailed documentation and keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#PhoXonic.DiscretizationMethod","page":"Core","title":"PhoXonic.DiscretizationMethod","text":"DiscretizationMethod\n\nAbstract type for material discretization methods.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.SimpleGrid","page":"Core","title":"PhoXonic.SimpleGrid","text":"SimpleGrid\n\nSimple point-sampling discretization. Each grid point gets the material value at that exact location.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.SubpixelAverage","page":"Core","title":"PhoXonic.SubpixelAverage","text":"SubpixelAverage\n\nSubpixel averaging for smoother material boundaries. Uses volume fractions to average material properties.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.PlaneWaveBasis","page":"Core","title":"PhoXonic.PlaneWaveBasis","text":"PlaneWaveBasis{D<:Dimension}\n\nPlane wave basis for D-dimensional periodic structures.\n\nFields\n\nlattice: The underlying lattice\ncutoff: Maximum index for plane waves\nindices: List of (p, q, ...) indices for each plane wave\nG: Reciprocal lattice vectors for each plane wave\nnum_pw: Total number of plane waves\n\n\n\n\n\n","category":"type"},{"location":"api/#PhoXonic.convolution_matrix","page":"Core","title":"PhoXonic.convolution_matrix","text":"convolution_matrix(f::AbstractMatrix, basis::PlaneWaveBasis{Dim2})\n\nCompute the convolution matrix for a 2D function f(r).\n\nThe convolution matrix C has elements:     C[i,j] = f̂(Gi - Gj) where f̂ is the Fourier transform of f.\n\nArguments\n\nf: Real-space function values on a grid (Nx × Ny)\nbasis: Plane wave basis\n\nReturns\n\nA complex matrix of size (numpw × numpw).\n\n\n\n\n\nconvolution_matrix(f::AbstractVector, basis::PlaneWaveBasis{Dim1})\n\nCompute the convolution matrix for a 1D function f(x).\n\n\n\n\n\nconvolution_matrix(f::AbstractArray{T,3}, basis::PlaneWaveBasis{Dim3}) where T\n\nCompute the convolution matrix for a 3D function f(r).\n\n\n\n\n\n","category":"function"},{"location":"elastic_void/#Elastic-Void-(Tanaka-Limit)","page":"Elastic Void (Tanaka Limit)","title":"Elastic Void (Tanaka Limit)","text":"This document explains how to handle void (vacuum/air) regions in phononic crystal calculations using the plane wave expansion (PWE) method.","category":"section"},{"location":"elastic_void/#The-Problem:-Void-in-PWE","page":"Elastic Void (Tanaka Limit)","title":"The Problem: Void in PWE","text":"The plane wave expansion method for elastic waves requires material properties (density ρ, elastic constants C) at every point. For void regions:\n\nVacuum: ρ = 0, C = 0 (no material)\nAir: Very low ρ and C compared to solids\n\nThis causes numerical problems because:\n\nDivision by zero: The eigenvalue problem involves terms like C/ρ\nSpurious flat bands: Setting ρ → 0 naively produces unphysical zero-frequency modes\nIll-conditioned matrices: Large property contrasts cause numerical instability","category":"section"},{"location":"elastic_void/#The-Tanaka-Limit-Solution","page":"Elastic Void (Tanaka Limit)","title":"The Tanaka Limit Solution","text":"Tanaka et al. (2000) proposed an elegant solution: instead of ρ → 0, use ρ/C → 0.\n\nThe key insight is that wave velocity v = √(C/ρ). By keeping C finite while making ρ small:\n\nv = √(C/ρ) → ∞  as ρ → 0 with C fixed\n\nThis pushes spurious modes to very high frequencies (ω ~ v → ∞), effectively removing them from the frequency range of interest.","category":"section"},{"location":"elastic_void/#Implementation-in-PhoXonic.jl","page":"Elastic Void (Tanaka Limit)","title":"Implementation in PhoXonic.jl","text":"void = ElasticVoid(ρ_ratio=1e-7)\n\nInternally, this creates a material with:\n\nμ = 1.0 (shear modulus, normalized)\nλ = 1.0 (Lamé parameter)\nρ = ρ_ratio × μ = 1e-7\n\nResulting velocities:\n\nv_T = √(μ/ρ) = √(1/1e-7) ≈ 3162 (transverse)\nv_L = √((λ+2μ)/ρ) ≈ 5477 (longitudinal)","category":"section"},{"location":"elastic_void/#Choosing-ρ_ratio","page":"Elastic Void (Tanaka Limit)","title":"Choosing ρ_ratio","text":"The ρ_ratio parameter controls the balance between:\n\nSmaller ρ_ratio Larger ρ_ratio\nSpurious bands pushed higher Spurious bands closer to physical bands\nBetter separation of physical/spurious modes Less separation\nPotentially worse numerical conditioning Better numerical stability\nMore accurate results May contaminate results","category":"section"},{"location":"elastic_void/#Recommended-Values","page":"Elastic Void (Tanaka Limit)","title":"Recommended Values","text":"ρ_ratio v_T Use case\n1e-6 ~1000 Quick calculations, lower accuracy\n1e-7 (default) ~3162 Recommended for most cases\n1e-8 ~10000 High accuracy, check for numerical issues","category":"section"},{"location":"elastic_void/#Verification","page":"Elastic Void (Tanaka Limit)","title":"Verification","text":"The default ρ_ratio=1e-7 was validated against:\n\nMaldovan 2006 (Si/void, triangular lattice, r/a=0.46)\nPaper: complete gap at ωa/2πcT = 0.830-0.963\nPhoXonic: PSV gap at 0.809-0.959 (within 3%)\nTanaka 2000 (Al/void, square lattice, f=0.55)\nComplete elastic gap around ωa/vT ~ 3.5-4.5","category":"section"},{"location":"elastic_void/#Usage-Example","page":"Elastic Void (Tanaka Limit)","title":"Usage Example","text":"See also: examples/210_vacuum_phononic.jl\n\nusing PhoXonic\n\n# Silicon matrix with vacuum holes\nsi = IsotropicElastic(ρ=2330.0, λ=4.67e10, μ=6.69e10)\nvoid = ElasticVoid()  # default ρ_ratio=1e-7\n\n# Triangular lattice\nlat = hexagonal_lattice(1.0)\ngeo = Geometry(lat, si, [(Circle([0.0, 0.0], 0.46), void)])\n\n# Solve\nsolver = Solver(PSVWave(), geo, (64, 64); cutoff=7)\nbands = compute_bands(solver, kpath; bands=1:10)","category":"section"},{"location":"elastic_void/#Identifying-Spurious-Bands","page":"Elastic Void (Tanaka Limit)","title":"Identifying Spurious Bands","text":"Spurious bands from void regions typically appear as:\n\nFlat or nearly flat bands at high frequencies\nBands with vT ≈ √(1/ρratio) × (matrix v_T)\n\nIf you see suspicious flat bands in your frequency range of interest, try decreasing ρ_ratio.","category":"section"},{"location":"elastic_void/#References","page":"Elastic Void (Tanaka Limit)","title":"References","text":"Y. Tanaka, Y. Tomoyasu, S. Tamura, \"Band structure of acoustic waves in phononic lattices: Two-dimensional composites with large acoustic mismatch,\" Phys. Rev. B 62, 7387 (2000). DOI:10.1103/PhysRevB.62.7387\nM. Maldovan, E.L. Thomas, \"Simultaneous complete elastic and electromagnetic band gaps in periodic structures,\" Appl. Phys. B 83, 595 (2006). DOI:10.1007/s00340-006-2241-y","category":"section"},{"location":"elastic_void/#API-Reference","page":"Elastic Void (Tanaka Limit)","title":"API Reference","text":"Core API - IsotropicElastic, ElasticVoid, fromEν","category":"section"},{"location":"workflow_1d/#1D-Calculations","page":"1D Calculations","title":"1D Calculations","text":"1D photonic and phononic crystal calculations for multilayer structures (Bragg reflectors, superlattices).","category":"section"},{"location":"workflow_1d/#1D-Wave-Types","page":"1D Calculations","title":"1D Wave Types","text":"(Image: 1D Wave Types)\n\nWave Type Field Description\nPhotonic1D E Electromagnetic wave in dielectric multilayer\nLongitudinal1D u Longitudinal elastic wave (P-wave) in elastic multilayer","category":"section"},{"location":"workflow_1d/#PWE-vs-TMM","page":"1D Calculations","title":"PWE vs TMM","text":"PhoXonic provides two methods for 1D band structure:\n\nMethod Description Best For\nPWE (Plane Wave Expansion) Fourier-based eigenvalue solver Band structure, eigenmodes\nTMM (Transfer Matrix) Exact matrix propagation Transmission spectra, finite structures\n\nBoth methods give identical band structures for periodic systems. TMM additionally provides transmission/reflection spectra.","category":"section"},{"location":"workflow_1d/#1D-Photonic-Crystal","page":"1D Calculations","title":"1D Photonic Crystal","text":"","category":"section"},{"location":"workflow_1d/#Bragg-Reflector","page":"1D Calculations","title":"Bragg Reflector","text":"See also: examples/301_bragg_reflector.jl\n\nA quarter-wave stack of two dielectric materials.\n\nusing PhoXonic\n\nlat = lattice_1d(1.0)\nmat1 = Dielectric(1.0)\nmat2 = Dielectric(12.0)\n\n# Quarter-wave stack: d1/d2 = n2/n1\nd1 = 0.5 * sqrt(12) / (1 + sqrt(12))\ngeo = Geometry(lat, mat1, [(Segment(0.0, d1), mat2)])\n\nsolver = Solver(Photonic1D(), geo, 128; cutoff=20)\n\n# Compute bands\nkpath = simple_kpath_1d(; a=1.0, npoints=50)\nbands = compute_bands(solver, kpath; bands=1:5)","category":"section"},{"location":"workflow_1d/#Joannopoulos-Ch4-Benchmark","page":"1D Calculations","title":"Joannopoulos Ch4 Benchmark","text":"See also: examples/311_joannopoulos_ch4_fig2.jl\n\nReproduces Figure 2 from \"Photonic Crystals: Molding the Flow of Light\" Chapter 4.","category":"section"},{"location":"workflow_1d/#1D-Phononic-Crystal","page":"1D Calculations","title":"1D Phononic Crystal","text":"","category":"section"},{"location":"workflow_1d/#Elastic-Superlattice","page":"1D Calculations","title":"Elastic Superlattice","text":"See also: examples/302_elastic_superlattice.jl\n\nAlternating layers of two elastic materials (e.g., steel/epoxy).\n\nusing PhoXonic\n\nlat = lattice_1d(0.01)  # 1 cm period\nsteel = IsotropicElastic(ρ=7800.0, λ=115e9, μ=82e9)\nepoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)\ngeo = Geometry(lat, epoxy, [(Segment(0.0, 0.5), steel)])\n\nsolver = Solver(Longitudinal1D(), geo, 128; cutoff=20)\n\n# Compute bands\nkpath = simple_kpath_1d(; a=0.01, npoints=50)\nbands = compute_bands(solver, kpath; bands=1:5)","category":"section"},{"location":"workflow_1d/#Iterative-Solvers","page":"1D Calculations","title":"Iterative Solvers","text":"1D problems support all solver methods:\n\n# Dense (default)\nsolver = Solver(Photonic1D(), geo, 128; cutoff=20)\n\n# KrylovKit\nsolver = Solver(Photonic1D(), geo, 128, KrylovKitMethod(); cutoff=20)\n\n# LOBPCG\nsolver = Solver(Photonic1D(), geo, 128, LOBPCGMethod(); cutoff=20)\n\nFor phononic problems with large eigenvalues, KrylovKitMethod applies automatic scaling.","category":"section"},{"location":"workflow_1d/#See-Also","page":"1D Calculations","title":"See Also","text":"Transfer Matrix Method (TMM) - Exact solution for transmission/reflection\nWorkflow (2D) - 2D photonic and phononic crystals\nSolver Methods - Dense, KrylovKit, LOBPCG comparison","category":"section"},{"location":"tmm/#Transfer-Matrix-Method-(1D)","page":"Transfer Matrix Method (1D)","title":"Transfer Matrix Method (1D)","text":"The Transfer Matrix Method (TMM) provides exact solutions for wave propagation in 1D multilayer structures. PhoXonic.jl supports TMM for both photonic and phononic crystals.","category":"section"},{"location":"tmm/#Overview","page":"Transfer Matrix Method (1D)","title":"Overview","text":"TMM uses an API similar to PWE, making it easy to compare results between the two methods. Both use the same wave types (Photonic1D, Longitudinal1D) and return compatible BandStructure objects, enabling direct validation of 1D calculations.\n\nTMM is particularly useful for:\n\nComputing transmission and reflection spectra of multilayer structures\nAnalyzing Bragg mirrors and Fabry-Pérot cavities\nBand structure calculation for 1D periodic systems\nHandling oblique incidence and polarization effects\nModeling lossy materials (complex permittivity)","category":"section"},{"location":"tmm/#Quick-Start","page":"Transfer Matrix Method (1D)","title":"Quick Start","text":"","category":"section"},{"location":"tmm/#Photonic-Bragg-Mirror","page":"Transfer Matrix Method (1D)","title":"Photonic Bragg Mirror","text":"See also: examples/601_tmm_bragg_mirror.jl\n\nusing PhoXonic\n\n# Define materials\nmat_hi = Dielectric(2.5^2)  # n = 2.5\nmat_lo = Dielectric(1.45^2) # n = 1.45\n\n# Design wavelength\nλ0 = 1.55\n\n# Quarter-wave layers\nd_hi = λ0 / (4 * 2.5)\nd_lo = λ0 / (4 * 1.45)\n\n# Create multilayer\nunit_cell = [Layer(mat_hi, d_hi), Layer(mat_lo, d_lo)]\nml = periodic_multilayer(unit_cell, 10)\n\n# Create solver\nsolver = TMMSolver(Photonic1D(), ml)\n\n# Compute transmission spectrum\nλ_values = range(0.8*λ0, 1.2*λ0, length=201)\nR, T = tmm_spectrum(solver, collect(λ_values))","category":"section"},{"location":"tmm/#Phononic-Superlattice","page":"Transfer Matrix Method (1D)","title":"Phononic Superlattice","text":"See also: examples/603_tmm_phononic.jl\n\nusing PhoXonic\n\n# Define elastic materials\nsteel = IsotropicElastic(ρ=7800.0, λ=115e9, μ=82e9)\nepoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)\n\n# Create multilayer\nunit_cell = [Layer(steel, 0.005), Layer(epoxy, 0.005)]\nml = periodic_multilayer(unit_cell, 10)\n\n# Create solver for longitudinal waves\nsolver = TMMSolver(Longitudinal1D(), ml)\n\n# Compute band structure\nbands = tmm_bandstructure(solver; k_points=51, bands=1:5)","category":"section"},{"location":"tmm/#Layer-and-Multilayer-Types","page":"Transfer Matrix Method (1D)","title":"Layer and Multilayer Types","text":"","category":"section"},{"location":"tmm/#Layer","page":"Transfer Matrix Method (1D)","title":"Layer","text":"A single layer is defined by its material and thickness:\n\nLayer(material, thickness)\n\nSupported materials:\n\nDielectric(ε) - lossless dielectric\nLossyDielectric(ε) - complex permittivity for absorption\nIsotropicElastic(ρ, λ, μ) - elastic material for phononic waves","category":"section"},{"location":"tmm/#Multilayer","page":"Transfer Matrix Method (1D)","title":"Multilayer","text":"A complete structure including surrounding media:\n\n# Manual construction\nMultilayer(layers::Vector{Layer}, left_material, right_material)\n\n# Periodic structure\nperiodic_multilayer(unit_cell::Vector{Layer}, n_periods)","category":"section"},{"location":"tmm/#TMMSolver","page":"Transfer Matrix Method (1D)","title":"TMMSolver","text":"The solver is created by specifying the wave type and structure:\n\n# Photonic (electromagnetic) waves\nsolver = TMMSolver(Photonic1D(), multilayer)\n\n# Phononic (longitudinal elastic) waves\nsolver = TMMSolver(Longitudinal1D(), multilayer)","category":"section"},{"location":"tmm/#Transmission-Spectrum","page":"Transfer Matrix Method (1D)","title":"Transmission Spectrum","text":"","category":"section"},{"location":"tmm/#Normal-Incidence","page":"Transfer Matrix Method (1D)","title":"Normal Incidence","text":"# Single wavelength\nresult = tmm_spectrum(solver, λ)\n# Returns: result.R (reflectivity), result.T (transmissivity)\n\n# Multiple wavelengths\nR, T = tmm_spectrum(solver, λ_values)\n# Returns: vectors of R and T values","category":"section"},{"location":"tmm/#Oblique-Incidence-(Photonic-only)","page":"Transfer Matrix Method (1D)","title":"Oblique Incidence (Photonic only)","text":"# TE polarization (s-polarized)\nresult = tmm_spectrum(solver, λ; angle=π/6, polarization=:TE)\n\n# TM polarization (p-polarized)\nresult = tmm_spectrum(solver, λ; angle=π/6, polarization=:TM)\n\nFeatures:\n\nHandles total internal reflection automatically\nBrewster angle effects for TM polarization\nEnergy conservation: R + T = 1 (for lossless materials)","category":"section"},{"location":"tmm/#Band-Structure","page":"Transfer Matrix Method (1D)","title":"Band Structure","text":"Compute the dispersion relation for periodic structures:\n\nbands = tmm_bandstructure(solver; k_points=51, bands=1:5)\n\nThe result is a BandStructure object compatible with PWE results:\n\nbands.k_points - wave vectors along the path\nbands.frequencies - eigenfrequencies (kpoints × nbands matrix)\nbands.k_labels - high-symmetry point labels","category":"section"},{"location":"tmm/#Bloch's-Theorem","page":"Transfer Matrix Method (1D)","title":"Bloch's Theorem","text":"For a periodic structure with period a, the eigenfrequencies satisfy:\n\ncos(ka) = Tr(M) / 2\n\nwhere M is the transfer matrix for one period. Bandgaps occur where |Tr(M)/2| > 1.","category":"section"},{"location":"tmm/#Lossy-Materials","page":"Transfer Matrix Method (1D)","title":"Lossy Materials","text":"TMM supports complex permittivity for modeling absorption:\n\n# Complex permittivity: ε = ε' + iε''\nmat_lossy = LossyDielectric(complex(4.0, 0.1))\n\n# Use in multilayer structure\nml = Multilayer([Layer(mat_lossy, d)], mat_air, mat_air)\nsolver = TMMSolver(Photonic1D(), ml)\n\n# For lossy materials: R + T + A = 1\nresult = tmm_spectrum(solver, λ)\nA = 1 - result.R - result.T  # Absorption\n\nNote: LossyDielectric is only supported for TMM, not PWE.","category":"section"},{"location":"tmm/#Examples","page":"Transfer Matrix Method (1D)","title":"Examples","text":"","category":"section"},{"location":"tmm/#Bragg-Mirror","page":"Transfer Matrix Method (1D)","title":"Bragg Mirror","text":"See also: examples/601_tmm_bragg_mirror.jl\n\nTransmission spectrum of a dielectric Bragg mirror with varying number of layer pairs.\n\nunit_cell = [Layer(mat_hi, d_hi), Layer(mat_lo, d_lo)]\nml = periodic_multilayer(unit_cell, 20)\nsolver = TMMSolver(Photonic1D(), ml)\n\nλ_values = range(0.8*λ0, 1.2*λ0, length=201)\nR, T = tmm_spectrum(solver, collect(λ_values))\n\n(Image: Bragg mirror spectrum)\n\n","category":"section"},{"location":"tmm/#Fabry-Pérot-Cavity","page":"Transfer Matrix Method (1D)","title":"Fabry-Pérot Cavity","text":"See also: examples/602_tmm_fabry_perot.jl\n\nResonance behavior of a Fabry-Pérot cavity with Bragg mirrors.\n\n# Symmetric structure: (HL)^N HH (LH)^N\nleft_layers = vcat([l for _ in 1:n_pairs for l in left_mirror_cell]...)\ndefect_layer = Layer(mat_hi, 2*d_hi)\nright_layers = vcat([l for _ in 1:n_pairs for l in right_mirror_cell]...)\n\nall_layers = vcat(left_layers, [defect_layer], right_layers)\nml = Multilayer(all_layers, mat_lo, mat_lo)\n\n(Image: Fabry-Pérot finesse)\n\n","category":"section"},{"location":"tmm/#Phononic-Superlattice-2","page":"Transfer Matrix Method (1D)","title":"Phononic Superlattice","text":"See also: examples/603_tmm_phononic.jl\n\nSteel/Epoxy multilayer for acoustic wave bandgaps.\n\nsteel = IsotropicElastic(ρ=7800.0, λ=115e9, μ=82e9)\nepoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)\n\nunit_cell = [Layer(steel, d_steel), Layer(epoxy, d_epoxy)]\nml = periodic_multilayer(unit_cell, 10)\nsolver = TMMSolver(Longitudinal1D(), ml)\n\nbands = tmm_bandstructure(solver; k_points=51, bands=1:4)\n\n(Image: Phononic band structure)\n\n","category":"section"},{"location":"tmm/#PWE-vs-TMM-Comparison","page":"Transfer Matrix Method (1D)","title":"PWE vs TMM Comparison","text":"See also: examples/604_tmm_vs_pwe.jl\n\nVerifies consistency between PWE and TMM for 1D structures.\n\n# TMM\nsolver_tmm = TMMSolver(Photonic1D(), ml)\nbands_tmm = tmm_bandstructure(solver_tmm; k_points=21, bands=1:5)\n\n# PWE\nsolver_pwe = Solver(Photonic1D(), geo, 256; cutoff=20)\n\n(Image: PWE vs TMM comparison)","category":"section"},{"location":"tmm/#Comparison-with-PWE","page":"Transfer Matrix Method (1D)","title":"Comparison with PWE","text":"Feature TMM PWE\nDimensionality 1D only 1D, 2D, 3D\nAccuracy (1D) Exact Fourier truncation\nTransmission/Reflection Direct Not available\nOblique incidence Yes No\nLossy materials Yes No\nArbitrary geometry No (layers only) Yes\nBand structure Via Bloch condition Direct eigenvalue\n\nFor 1D periodic structures, TMM and PWE should give identical band structures within numerical precision.","category":"section"},{"location":"tmm/#API-Reference","page":"Transfer Matrix Method (1D)","title":"API Reference","text":"","category":"section"},{"location":"tmm/#Types","page":"Transfer Matrix Method (1D)","title":"Types","text":"Layer{M} - single layer with material type M\nMultilayer{M} - complete multilayer structure\nTMMSolver{W,M} - solver for wave type W and material type M","category":"section"},{"location":"tmm/#Functions","page":"Transfer Matrix Method (1D)","title":"Functions","text":"tmm_spectrum(solver, λ) - compute R, T at wavelength λ\ntmm_spectrum(solver, λ_values) - compute R, T spectrum\ntmm_bandstructure(solver; ...) - compute band structure\nperiodic_multilayer(unit_cell, n) - create periodic structure\nrefractive_index(material) - get refractive index\nacoustic_impedance(material) - get acoustic impedance (phononic)","category":"section"},{"location":"tmm/#See-Also","page":"Transfer Matrix Method (1D)","title":"See Also","text":"Core API - Dielectric, IsotropicElastic materials","category":"section"},{"location":"greens_function/#DOS-/-LDOS","page":"DOS / LDOS","title":"DOS / LDOS","text":"Density of States (DOS) and Local Density of States (LDOS) computation using Green's function methods.\n\nFor large-scale calculations, MatrixFreeGF() uses FFT-based operators described in Matrix-Free Methods.","category":"section"},{"location":"greens_function/#Setup","page":"DOS / LDOS","title":"Setup","text":"using PhoXonic\n\n# For DirectGF (no additional dependencies required)\nG = compute_greens_function(solver, k, ω_values, source, DirectGF(); η=0.01)\n\n# For RSKGF and MatrixFreeGF, load ReducedShiftedKrylov.jl\nusing ReducedShiftedKrylov  # Automatically enables extension\n\nG = compute_greens_function(solver, k, ω_values, source, RSKGF(); η=0.01)\nG = compute_greens_function(solver, k, ω_values, source, MatrixFreeGF(); η=0.01)\n\nnote: Optional Dependency\nRSKGF and MatrixFreeGF methods require the ReducedShiftedKrylov.jl package. When you load it with using ReducedShiftedKrylov, the extension is automatically enabled.","category":"section"},{"location":"greens_function/#Available-Methods","page":"DOS / LDOS","title":"Available Methods","text":"Method Memory Best For Requires RSK\nDirectGF() O(N²) Small systems, high accuracy No\nRSKGF() O(N²) Many frequencies, 2D Yes\nMatrixFreeGF() O(N) Large systems, 2D/3D Yes","category":"section"},{"location":"greens_function/#DirectGF","page":"DOS / LDOS","title":"DirectGF","text":"Direct LU factorization method. Most accurate but requires O(N²) memory for the matrix.\n\nmethod = DirectGF()","category":"section"},{"location":"greens_function/#RSKGF","page":"DOS / LDOS","title":"RSKGF","text":"Uses the Reduced Shifted Conjugate Gradient (RSCG) method from ReducedShiftedKrylov.jl. Efficient for computing Green's functions at many frequency points simultaneously.\n\nmethod = RSKGF(; atol=1e-10, rtol=1e-10, itmax=1000, verbose=false)","category":"section"},{"location":"greens_function/#MatrixFreeGF","page":"DOS / LDOS","title":"MatrixFreeGF","text":"Matrix-free implementation using FFT-based operators. O(N) memory, suitable for large-scale 2D and 3D calculations.\n\n# Default: ApproximateRHSInv (fast, good for low contrast)\nmethod = MatrixFreeGF()\n\n# Explicit ApproximateRHSInv\nmethod = MatrixFreeGF(rhs_inv_method=ApproximateRHSInv())\n\n# CGRHSInv for high-contrast materials (more accurate)\nmethod = MatrixFreeGF(rhs_inv_method=CGRHSInv())\n\n# CGRHSInv with custom parameters\nmethod = MatrixFreeGF(rhs_inv_method=CGRHSInv(atol=1e-12, rtol=1e-12, maxiter=200))","category":"section"},{"location":"greens_function/#RHSInvMethod-Options","page":"DOS / LDOS","title":"RHSInvMethod Options","text":"For MatrixFreeGF, you can choose how to handle the RHS (right-hand side) matrix inversion:\n\nMethod Description Best For\nApproximateRHSInv() Element-wise 1/ε in real space Low contrast materials\nCGRHSInv() Iterative CG solve High contrast materials\n\n# CGRHSInv parameters\nCGRHSInv(; atol=1e-10, rtol=1e-10, maxiter=100)","category":"section"},{"location":"greens_function/#Functions","page":"DOS / LDOS","title":"Functions","text":"","category":"section"},{"location":"greens_function/#[compute*greens*function](api-advanced.md#PhoXonic.compute_greens_function)","page":"DOS / LDOS","title":"computegreensfunction","text":"Compute the Green's function G(ω) = (ω² - H)⁻¹ for multiple frequencies.\n\nG_values = compute_greens_function(solver, k, ω_values, source, method; η=1e-3)\n\nArguments:\n\nsolver: Solver instance\nk: Wave vector (e.g., [0.0, 0.0])\nω_values: Vector of frequencies\nsource: Source vector in plane wave basis\nmethod: DirectGF(), RSKGF(), or MatrixFreeGF()\nη: Broadening parameter (imaginary part of ω²)\n\nReturns: Vector of Green's function solutions, one for each frequency.","category":"section"},{"location":"greens_function/#[compute_ldos](api-advanced.md#PhoXonic.compute_ldos)","page":"DOS / LDOS","title":"compute_ldos","text":"Compute the Local Density of States at a specific position.\n\nldos = compute_ldos(solver, position, ω_values, k_points, method; η=1e-3)\n\nArguments:\n\nsolver: Solver instance\nposition: Real-space position (e.g., [0.5, 0.5])\nω_values: Vector of frequencies\nk_points: Vector of k-points for BZ sampling\nmethod: DirectGF(), RSKGF(), or MatrixFreeGF()\nη: Broadening parameter\n\nReturns: Vector of LDOS values for each frequency.","category":"section"},{"location":"greens_function/#[compute_dos](api-advanced.md#PhoXonic.compute_dos)","page":"DOS / LDOS","title":"compute_dos","text":"Compute the Density of States (stochastic trace method for RSKGF/MatrixFreeGF).\n\ndos = compute_dos(solver, ω_values, k_points, method; η=1e-3, n_random=10)\n\nArguments:\n\nsolver: Solver instance\nω_values: Vector of frequencies\nk_points: Vector of k-points for BZ sampling\nmethod: DirectGF(), RSKGF(), or MatrixFreeGF()\nη: Broadening parameter\nn_random: Number of random vectors for stochastic trace (RSKGF/MatrixFreeGF only)\n\nReturns: Vector of DOS values for each frequency.","category":"section"},{"location":"greens_function/#Examples","page":"DOS / LDOS","title":"Examples","text":"See also: examples/501_defect_mode.jl - Defect mode finding with LDOS","category":"section"},{"location":"greens_function/#Basic-LDOS-Calculation","page":"DOS / LDOS","title":"Basic LDOS Calculation","text":"using PhoXonic\n\n# Setup\nlat = square_lattice(1.0)\nair = Dielectric(1.0)\nrod = Dielectric(4.0)\ngeo = Geometry(lat, air, [(Circle([0.0, 0.0], 0.2), rod)])\nsolver = Solver(TEWave(), geo, (32, 32); cutoff=5)\n\n# LDOS with DirectGF (no extra dependencies)\nposition = [0.5, 0.5]\nω_values = collect(0.2:0.01:0.8)\nk_points = [[0.0, 0.0]]\n\nldos = compute_ldos(solver, position, ω_values, k_points, DirectGF(); η=0.01)","category":"section"},{"location":"greens_function/#Matrix-Free-LDOS-(requires-ReducedShiftedKrylov)","page":"DOS / LDOS","title":"Matrix-Free LDOS (requires ReducedShiftedKrylov)","text":"using PhoXonic\nusing ReducedShiftedKrylov  # Enable extension\n\n# ... (same setup as above)\n\n# Matrix-free LDOS for large systems\nldos_mf = compute_ldos(solver, position, ω_values, k_points, MatrixFreeGF(); η=0.01)\n\n# With CGRHSInv for high-contrast materials\nldos_cg = compute_ldos(solver, position, ω_values, k_points,\n                        MatrixFreeGF(rhs_inv_method=CGRHSInv()); η=0.01)","category":"section"},{"location":"greens_function/#Finding-Defect-Modes","page":"DOS / LDOS","title":"Finding Defect Modes","text":"See examples_rsk/502_defect_mode_matrixfree.jl for a complete example of using matrix-free methods to find defect modes in photonic crystal supercells.","category":"section"},{"location":"greens_function/#Dimension-Support","page":"DOS / LDOS","title":"Dimension Support","text":"Method 1D 2D 3D\nDirectGF() Yes Yes No\nRSKGF() No Yes No\nMatrixFreeGF() No Yes Yes","category":"section"},{"location":"greens_function/#See-Also","page":"DOS / LDOS","title":"See Also","text":"Advanced API - GFMethod, computedos, computeldos\nMatrix-Free Methods for operators and FFT context\nexamples_rsk/ directory for RSK-dependent examples","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This guide will help you get your first band structure calculation running in under 5 minutes.","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"using Pkg\nPkg.add(\"PhoXonic\")\nPkg.add(\"Plots\")  # For plotting","category":"section"},{"location":"getting_started/#Your-First-Calculation:-2D-Photonic-Crystal","page":"Getting Started","title":"Your First Calculation: 2D Photonic Crystal","text":"See also: examples/101_triangular_rods.jl\n\nLet's compute the band structure of a 2D photonic crystal with dielectric rods in a triangular lattice.","category":"section"},{"location":"getting_started/#Step-1:-Define-the-Structure","page":"Getting Started","title":"Step 1: Define the Structure","text":"A triangular lattice photonic crystal with dielectric rods (ε = 12) in air.\n\nusing PhoXonic\n\n# Create triangular (hexagonal) lattice with period a = 1\nlat = hexagonal_lattice(1.0)\n\n# Define materials\nair = Dielectric(1.0)\nrod = Dielectric(12.0)  # High dielectric (e.g., GaAs or Si)\n\n# Geometry: air background with dielectric rod at center\ngeo = Geometry(lat, air, [(Circle([0.0, 0.0], 0.2), rod)])","category":"section"},{"location":"getting_started/#Step-2:-Create-Solver-and-Compute-Bands","page":"Getting Started","title":"Step 2: Create Solver and Compute Bands","text":"# Create solver for TM polarization\nsolver = Solver(TMWave(), geo, (64, 64); cutoff=7)\n\n# Define k-path: Γ → M → K → Γ\nkpath = simple_kpath_hexagonal(; a=1.0, npoints=30)\n\n# Compute band structure\nbands = compute_bands(solver, kpath; bands=1:8)\n\nParameters:\n\n(64, 64): Grid resolution for discretizing the unit cell\ncutoff=7: Number of reciprocal lattice vectors included (higher = more accurate but slower)\n\nThe returned bands object is a BandStructure containing frequencies, k-points, and labels. It can be passed directly to plot_bands and find_all_gaps. See Workflow for details.","category":"section"},{"location":"getting_started/#Step-3:-Find-Band-Gaps","page":"Getting Started","title":"Step 3: Find Band Gaps","text":"gaps = find_all_gaps(bands)\nfor g in gaps\n    println(\"Gap between bands $(g.bands): $(round(g.gap_ratio*100; digits=1))% gap-to-midgap\")\nend\n\nExpected output:\n\nGap between bands (1, 2): 47.4% gap-to-midgap","category":"section"},{"location":"getting_started/#Plotting-the-Band-Structure","page":"Getting Started","title":"Plotting the Band Structure","text":"using Plots\n\nplot_bands(bands;\n    xlabel = \"Wave vector\",\n    ylabel = \"Frequency (ωa/2πc)\",\n    title = \"2D Photonic Crystal (TM)\"\n)\n\n(Image: 2D Photonic Crystal Band Structure)\n\nThis band diagram shows a clear photonic band gap between the first and second bands (~50% gap-to-midgap ratio).","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Now that you've run your first calculation, explore more:\n\nWorkflow: Detailed workflow for 2D photonic and phononic crystals\n3D Calculations: Full vector EM and elastic wave calculations\nExamples: Complete example scripts with various structures\nSolver Methods: Choose the right solver for your problem size\nAPI Reference: Full documentation of all functions","category":"section"},{"location":"getting_started/#Quick-Reference","page":"Getting Started","title":"Quick Reference","text":"Structure Wave Type Lattice Example\n1D photonic Photonic1D() lattice_1d(a) 301\n1D phononic Longitudinal1D() lattice_1d(a) 302\n2D photonic TE TEWave() square_lattice(a), hexagonal_lattice(a) 103\n2D photonic TM TMWave() square_lattice(a), hexagonal_lattice(a) 101\n2D phononic SH SHWave() square_lattice(a), hexagonal_lattice(a) 201\n2D phononic P-SV PSVWave() square_lattice(a), hexagonal_lattice(a) 201\n3D photonic TransverseEM() cubic_lattice(a), fcc_lattice(a) 401\n3D phononic FullElastic() cubic_lattice(a), fcc_lattice(a) —","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#2D-Photonic-Crystals","page":"Examples","title":"2D Photonic Crystals","text":"","category":"section"},{"location":"examples/#Triangular-Lattice-Rods-(TM-mode)","page":"Examples","title":"Triangular Lattice Rods (TM mode)","text":"Source: examples/101_triangular_rods.jl\n\nDielectric rods (ε=12) in air, radius r=0.2a.\n\n(Image: Triangular lattice structure)\n\nlat = hexagonal_lattice(1.0)\nair = Dielectric(1.0)\nrod = Dielectric(12.0)\ngeo = Geometry(lat, air, [(Circle([0.0, 0.0], 0.2), rod)])\n\nsolver = Solver(TMWave(), geo, (64, 64); cutoff=7)\nkpath = simple_kpath_hexagonal(npoints=30)\nbands = compute_bands(solver, kpath; bands=1:8)\n\n(Image: TM band structure)\n\nThe TM mode shows a clear band gap between bands 1 and 2.\n\n","category":"section"},{"location":"examples/#Square-Lattice-Rods-(TE/TM-comparison)","page":"Examples","title":"Square Lattice Rods (TE/TM comparison)","text":"Source: examples/103_square_rods.jl\n\n(Image: Square lattice structure)\n\nlat = square_lattice(1.0)\ngeo = Geometry(lat, air, [(Circle([0.0, 0.0], 0.2), rod)])\n\nsolver_te = Solver(TEWave(), geo, (64, 64); cutoff=7)\nsolver_tm = Solver(TMWave(), geo, (64, 64); cutoff=7)\n\n(Image: Square lattice TE/TM bands)\n\nThis example also demonstrates iterative solvers:\n\n# KrylovKit (Arnoldi iteration)\nsolver = Solver(TMWave(), geo, (64, 64), KrylovKitMethod())\n\n# LOBPCG (Block CG)\nsolver = Solver(TMWave(), geo, (64, 64), LOBPCGMethod())\n\n","category":"section"},{"location":"examples/#2D-Phononic-Crystals","page":"Examples","title":"2D Phononic Crystals","text":"","category":"section"},{"location":"examples/#Steel/Epoxy-(SH-and-P-SV-modes)","page":"Examples","title":"Steel/Epoxy (SH and P-SV modes)","text":"Source: examples/201_phononic_steel_epoxy.jl\n\nSteel cylinders in epoxy matrix.\n\nepoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)\nsteel = IsotropicElastic(ρ=7800.0, λ=1.15e11, μ=8.28e10)\n\nlat = square_lattice(0.01)  # 1 cm period\ngeo = Geometry(lat, epoxy, [(Circle([0.0, 0.0], 0.004), steel)])\n\nsolver_sh = Solver(SHWave(), geo, (64, 64); cutoff=7)\nsolver_psv = Solver(PSVWave(), geo, (64, 64); cutoff=7)\n\n(Image: Phononic bands (SH and P-SV))\n\nThis example also compares Dense, KrylovKit, and LOBPCG methods for phononic problems.\n\n","category":"section"},{"location":"examples/#Solver-Comparison-(Dense-vs-LOBPCG)","page":"Examples","title":"Solver Comparison (Dense vs LOBPCG)","text":"Source: examples/207_solver_simple.jl, examples/208_solver_comparison.jl\n\nBenchmark Dense and LOBPCG solvers for phononic band structure calculations.\n\n# Dense solver (default, exact)\nsolver_dense = Solver(PSVWave(), geo, (64, 64); cutoff=15)\n\n# LOBPCG solver (faster for large problems)\nsolver_lobpcg = Solver(PSVWave(), geo, (64, 64), LOBPCGMethod(); cutoff=15)\n\nbands = compute_bands(solver, kpath; bands=1:10)\n\nLOBPCG becomes faster than Dense for cutoff ≥ 12. See LOBPCGMethod for details.\n\n","category":"section"},{"location":"examples/#1D-Structures","page":"Examples","title":"1D Structures","text":"","category":"section"},{"location":"examples/#Bragg-Reflector","page":"Examples","title":"Bragg Reflector","text":"Source: examples/301_bragg_reflector.jl\n\nQuarter-wave stack of two dielectric materials.\n\n(Image: Bragg structure)\n\nlat = lattice_1d(1.0)\nmat1 = Dielectric(1.0)\nmat2 = Dielectric(12.0)\n\n# Quarter-wave thickness ratio\nd1 = 0.5 * sqrt(12) / (1 + sqrt(12))\ngeo = Geometry(lat, mat1, [(Segment(0.0, d1), mat2)])\n\nsolver = Solver(Photonic1D(), geo, 128; cutoff=20)\n\n# Or with iterative solvers\nsolver = Solver(Photonic1D(), geo, 128, KrylovKitMethod(); cutoff=20)\nsolver = Solver(Photonic1D(), geo, 128, LOBPCGMethod(); cutoff=20)\n\n(Image: Bragg band structure)\n\n","category":"section"},{"location":"examples/#3D-Photonic-Crystals","page":"Examples","title":"3D Photonic Crystals","text":"For 3D photonic crystals, TransverseEM is the recommended wave type. It uses a 2N×2N transverse basis that automatically satisfies ∇·H = 0, eliminating spurious longitudinal modes.","category":"section"},{"location":"examples/#FCC-Lattice-with-Spheres","page":"Examples","title":"FCC Lattice with Spheres","text":"Source: examples/401_fcc_spheres.jl\n\nDielectric spheres (ε=12) in air on an FCC lattice.\n\nlat = fcc_lattice(1.0)\nair = Dielectric(1.0)\nsphere = Dielectric(12.0)\ngeo = Geometry(lat, air, [(Sphere([0.0, 0.0, 0.0], 0.25), sphere)])\n\n# TransverseEM: recommended for 3D photonic crystals\nsolver = Solver(TransverseEM(), geo, (16, 16, 16), DenseMethod(); cutoff=5)\n\n# Use 3D k-path\nkpath = simple_kpath_fcc(a=1.0, npoints=20)\nbands = compute_bands(solver, kpath; bands=1:6)\n\n","category":"section"},{"location":"examples/#Simple-Cubic-Lattice-with-Spheres","page":"Examples","title":"Simple Cubic Lattice with Spheres","text":"Source: examples/402_sc_spheres.jl\n\nlat = cubic_lattice(1.0)\ngeo = Geometry(lat, air, [(Sphere([0.0, 0.0, 0.0], 0.3), sphere)])\n\nsolver = Solver(TransverseEM(), geo, (16, 16, 16), DenseMethod(); cutoff=5)\nkpath = simple_kpath_cubic(a=1.0, npoints=20)\nbands = compute_bands(solver, kpath; bands=1:6)\n\n","category":"section"},{"location":"examples/#More-Examples","page":"Examples","title":"More Examples","text":"See the examples/ directory in the repository for additional examples:\n\nCategory File Description\n2D Photonic 102_triangular_rods_plot.jl Triangular lattice with plotting\n2D Photonic 104_honeycomb_rods.jl Honeycomb lattice\n2D Photonic 111_triangular_holes.jl Air holes in dielectric\n2D Photonic 121_subpixel_comparison.jl Convergence with subpixel averaging\n2D Photonic 911_joannopoulos_ch5_fig2.jl Joannopoulos Ch5 Fig2 benchmark\n2D Photonic 912_joannopoulos_ch5_fig10.jl Joannopoulos Ch5 Fig10 benchmark\n2D Phononic 202_phononic_pb_epoxy_benchmark.jl Pb/Epoxy benchmark\n2D Phononic 203_vasseur2001_benchmark.jl Vasseur 2001 benchmark\n2D Phononic 205_kushwaha1993_benchmark.jl Kushwaha 1993 benchmark\n2D Phononic 207_solver_simple.jl Dense vs LOBPCG comparison\n2D Phononic 208_solver_comparison.jl Solver benchmark across sizes\n2D Phononic 209_warmstart_benchmark.jl Warm start performance\n2D Phononic 210_vacuum_phononic.jl Vacuum holes (ElasticVoid)\n2D Phononic 211_kushwaha1993_fig1.jl Kushwaha 1993 Fig1\n2D Phononic 212_kushwaha1993_fig2.jl Kushwaha 1993 Fig2\n2D Phononic 213_tanaka2000_vacuum_al.jl Tanaka 2000 Al/vacuum\n2D Phononic 214_maldovan2006_phoxonic.jl Maldovan 2006 phoxonic\n1D Photonic 311_joannopoulos_ch4_fig2.jl Joannopoulos Ch4 Fig2\n1D Elastic 302_elastic_superlattice.jl Elastic wave superlattice\n3D Photonic 411_joannopoulos_ch6_fig3.jl FCC lattice benchmark\n3D Photonic 412_joannopoulos_ch6_fig8.jl Diamond lattice\n3D Photonic 413_mpb_diamond.jl MPB diamond comparison\n3D Photonic 901_mpb_benchmark.jl MPB benchmark\nDefect 501_defect_mode.jl Defect states and LDOS\nDefect 511_supercell_study.jl Supercell size study\nTMM 601_tmm_bragg_mirror.jl Bragg mirror spectrum\nTMM 602_tmm_fabry_perot.jl Fabry-Pérot cavity\nTMM 603_tmm_phononic.jl Phononic superlattice\nTMM 604_tmm_vs_pwe.jl TMM vs PWE comparison\nUtility 801_plot_structures.jl Structure visualization","category":"section"},{"location":"workflow/#Workflow-(2D)","page":"Workflow (2D)","title":"Workflow (2D)","text":"","category":"section"},{"location":"workflow/#Wave-Types-and-Polarizations","page":"Workflow (2D)","title":"Wave Types and Polarizations","text":"PhoXonic.jl supports various wave types for photonic and phononic crystals.","category":"section"},{"location":"workflow/#2D-Wave-Types","page":"Workflow (2D)","title":"2D Wave Types","text":"(Image: 2D Wave Polarizations)\n\nWave Type Field Components Description\nTEWave H_z E in xy-plane, H perpendicular\nTMWave E_z H in xy-plane, E perpendicular\nSHWave u_z Shear horizontal (anti-plane)\nPSVWave ux, uy In-plane (P + SV coupled)\n\nFor 3D wave types, see 3D Calculations.","category":"section"},{"location":"workflow/#Basic-Workflow","page":"Workflow (2D)","title":"Basic Workflow","text":"Define Lattice (square_lattice, hexagonal_lattice, etc.)\nDefine Materials (Dielectric, IsotropicElastic)\nCreate Geometry with Shapes (Circle, Rectangle, Sphere, etc.)\nCreate Solver with Wave Types — see also Solver Methods\nCompute Band Structure (compute_bands)\nAnalyze results — see Analysis and Post-Processing","category":"section"},{"location":"workflow/#2D-Photonic-Crystal","page":"Workflow (2D)","title":"2D Photonic Crystal","text":"","category":"section"},{"location":"workflow/#Triangular-Lattice-Rods-(TM-mode)","page":"Workflow (2D)","title":"Triangular Lattice Rods (TM mode)","text":"See also: examples/101_triangular_rods.jl\n\nusing PhoXonic\n\n# 1. Lattice\nlat = hexagonal_lattice(1.0)\n\n# 2. Materials\nair = Dielectric(1.0)\nrod = Dielectric(12.0)  # High-ε like GaAs\n\n# 3. Geometry: rods in air\ngeo = Geometry(lat, air, [(Circle([0.0, 0.0], 0.2), rod)])\n\n# 4. Solver\nsolver = Solver(TMWave(), geo, (64, 64); cutoff=7)\n\n# 5. Compute bands\nkpath = simple_kpath_hexagonal(npoints=30)\nbands = compute_bands(solver, kpath; bands=1:8)\n\n# 6. Find gaps\ngaps = find_all_gaps(bands)\nfor g in gaps\n    println(\"Gap between bands $(g.bands): $(g.gap_ratio*100)%\")\nend","category":"section"},{"location":"workflow/#Square-Lattice-(TE/TM-comparison)","page":"Workflow (2D)","title":"Square Lattice (TE/TM comparison)","text":"See also: examples/103_square_rods.jl\n\nlat = square_lattice(1.0)\ngeo = Geometry(lat, air, [(Circle([0.0, 0.0], 0.2), rod)])\n\n# TE mode\nsolver_te = Solver(TEWave(), geo, (64, 64); cutoff=7)\nbands_te = compute_bands(solver_te, kpath; bands=1:8)\n\n# TM mode\nsolver_tm = Solver(TMWave(), geo, (64, 64); cutoff=7)\nbands_tm = compute_bands(solver_tm, kpath; bands=1:8)","category":"section"},{"location":"workflow/#2D-Phononic-Crystal","page":"Workflow (2D)","title":"2D Phononic Crystal","text":"","category":"section"},{"location":"workflow/#Steel/Epoxy-(SH-mode)","page":"Workflow (2D)","title":"Steel/Epoxy (SH mode)","text":"See also: examples/201_phononic_steel_epoxy.jl\n\n# Materials\nepoxy = IsotropicElastic(ρ=1180.0, λ=4.43e9, μ=1.59e9)\nsteel = IsotropicElastic(ρ=7800.0, λ=1.15e11, μ=8.28e10)\n\n# Geometry\nlat = square_lattice(0.01)  # 1 cm period\ngeo = Geometry(lat, epoxy, [(Circle([0.0, 0.0], 0.004), steel)])\n\n# SH solver\nsolver = Solver(SHWave(), geo, (64, 64); cutoff=7)\nkpath = simple_kpath_square(a=0.01, npoints=30)\nbands = compute_bands(solver, kpath; bands=1:8)","category":"section"},{"location":"workflow/#P-SV-Mode-(in-plane)","page":"Workflow (2D)","title":"P-SV Mode (in-plane)","text":"solver_psv = Solver(PSVWave(), geo, (64, 64); cutoff=7)\nbands_psv = compute_bands(solver_psv, kpath; bands=1:12)","category":"section"},{"location":"workflow/#Subpixel-Averaging","page":"Workflow (2D)","title":"Subpixel Averaging","text":"For smoother convergence at material boundaries:\n\nsolver = Solver(TMWave(), geo, (64, 64);\n    cutoff=7,\n    discretization=SubpixelAverage(4)  # 4×4 subsampling\n)\n\nFor 3D photonic/phononic crystals (TransverseEM, FullVectorEM, FullElastic), see 3D Calculations.\n\nFor solver methods (DenseMethod, KrylovKitMethod, LOBPCGMethod), see Solver Methods.\n\nFor post-processing (convergence, group velocity, k-path, plotting, saving/loading), see Analysis and Post-Processing.","category":"section"},{"location":"workflow/#API-Reference","page":"Workflow (2D)","title":"API Reference","text":"Core API - Lattice, Materials, Shapes, Geometry\nSolver API - Wave types, Solver, BandStructure","category":"section"},{"location":"#PhoXonic.jl","page":"Home","title":"PhoXonic.jl","text":"Band structure calculation for photonic and phononic crystals using the plane wave expansion (PWE) method.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"PhoXonic.jl computes eigenfrequencies and eigenmodes of periodic structures:\n\nPhotonic crystals: 1D multilayer, TE/TM (2D), TransverseEM (3D)\nPhononic crystals: 1D longitudinal, SH/P-SV (2D), FullElastic (3D, experimental)\n\nThe name \"PhoXonic\" comes from Phoxonic crystals - structures that exhibit both photonic and phononic band gaps simultaneously.","category":"section"},{"location":"#Plane-Wave-Expansion-Method","page":"Home","title":"Plane Wave Expansion Method","text":"The PWE method solves the eigenvalue problem in reciprocal space by expanding fields in plane waves:\n\npsi(mathbfr) = sum_mathbfG psi_mathbfG e^i(mathbfk+mathbfG)cdotmathbfr","category":"section"},{"location":"#Photonic-Crystals","page":"Home","title":"Photonic Crystals","text":"For electromagnetic waves in periodic dielectric structures, Maxwell's equations lead to:\n\nTE mode (H_z):\n\n-nabla cdot left( frac1varepsilon nabla H_z right) = fracomega^2c^2 mu H_z\n\nTM mode (E_z):\n\n-frac1mu nabla^2 E_z = fracomega^2c^2 varepsilon E_z","category":"section"},{"location":"#Phononic-Crystals","page":"Home","title":"Phononic Crystals","text":"For elastic waves in periodic structures:\n\nSH mode (u_z, out-of-plane):\n\n-nabla cdot (C_44 nabla u_z) = omega^2 rho u_z\n\nP-SV mode (ux, uy, in-plane):\n\n-nabla cdot boldsymbolsigma = omega^2 rho mathbfu","category":"section"},{"location":"#Units","page":"Home","title":"Units","text":"PhoXonic.jl uses dimensionless units following the convention of MPB and Peacock.jl:","category":"section"},{"location":"#Photonic-Crystals-2","page":"Home","title":"Photonic Crystals","text":"Length: in units of lattice constant a\nFrequency: in units of ca (or omega a  2pi c)\nWave vector: in units of 2pia\n\nTo convert to physical units:\n\nf [Hz] = ω × c / a\nλ [m] = a / ω","category":"section"},{"location":"#Phononic-Crystals-2","page":"Home","title":"Phononic Crystals","text":"Length: in units of lattice constant a\nFrequency: omega from eigenvalue (units depend on material constants)\n\nFor physical frequencies, material constants should be in consistent SI units (Pa, kg/m³).","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Multiple lattice types: square, hexagonal, cubic, FCC, BCC\nSubpixel averaging for smooth boundaries\nBand gap detection\nGroup velocity computation\nBrillouin.jl integration for k-paths\nMultiple solver methods: Dense, KrylovKit.jl (iterative), LOBPCG (IterativeSolvers.jl)\nMatrix-free operators for large-scale 3D calculations (FFTW.jl, LinearMaps.jl)\nRSCG for Green's function / DOS / LDOS computation (Krylov.jl)","category":"section"},{"location":"#Related-Projects","page":"Home","title":"Related Projects","text":"Peacock.jl - 2D photonic crystals in Julia (design inspiration). S. J. Palmer and V. Giannini, JOSS 5, 2678 (2020). DOI:10.21105/joss.02678\nMPB - MIT Photonic-Bands","category":"section"},{"location":"#References","page":"Home","title":"References","text":"J. D. Joannopoulos et al., \"Photonic Crystals: Molding the Flow of Light\", Princeton University Press (2008). Book\nM. S. Kushwaha et al., Phys. Rev. Lett. 71, 2022 (1993). DOI:10.1103/PhysRevLett.71.2022 - Phononic crystals\nS. G. Johnson and J. D. Joannopoulos, \"Block-iterative frequency-domain methods for Maxwell's equations\", Opt. Express 8, 173 (2001). DOI:10.1364/OE.8.000173 - MPB","category":"section"}]
}

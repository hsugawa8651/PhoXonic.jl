<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solver Methods · PhoXonic.jl</title><meta name="title" content="Solver Methods · PhoXonic.jl"/><meta property="og:title" content="Solver Methods · PhoXonic.jl"/><meta property="twitter:title" content="Solver Methods · PhoXonic.jl"/><meta name="description" content="Documentation for PhoXonic.jl."/><meta property="og:description" content="Documentation for PhoXonic.jl."/><meta property="twitter:description" content="Documentation for PhoXonic.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PhoXonic.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../workflow/">Workflow (2D)</a></li><li><a class="tocitem" href="../workflow_1d/">1D Calculations</a></li><li><a class="tocitem" href="../workflow_3d/">3D Calculations</a></li><li class="is-active"><a class="tocitem" href>Solver Methods</a><ul class="internal"><li><a class="tocitem" href="#Memory-and-Computational-Cost"><span>Memory and Computational Cost</span></a></li><li><a class="tocitem" href="#Recommendations"><span>Recommendations</span></a></li><li><a class="tocitem" href="#DenseMethod"><span>DenseMethod</span></a></li><li><a class="tocitem" href="#KrylovKitMethod"><span>KrylovKitMethod</span></a></li><li><a class="tocitem" href="#LOBPCGMethod"><span>LOBPCGMethod</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li></ul></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li><a class="tocitem" href="../greens_function/">DOS / LDOS</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../matrixfree/">Matrix-Free Methods</a></li><li><a class="tocitem" href="../elastic_void/">Elastic Void (Tanaka Limit)</a></li><li><a class="tocitem" href="../tmm/">Transfer Matrix Method (1D)</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Core</a></li><li><a class="tocitem" href="../api-solver/">Solver</a></li><li><a class="tocitem" href="../api-advanced/">Advanced</a></li><li><a class="tocitem" href="../api-plotting/">Plotting</a></li><li><a class="tocitem" href="../api-io/">I/O</a></li></ul></li><li><a class="tocitem" href="../dependencies/">Dependencies</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Solver Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solver Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hsugawa8651/PhoXonic.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/docs/src/solver.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solver-Methods"><a class="docs-heading-anchor" href="#Solver-Methods">Solver Methods</a><a id="Solver-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-Methods" title="Permalink"></a></h1><p>PhoXonic.jl provides multiple solver methods for different problem sizes:</p><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Matrix Storage</th><th style="text-align: right">Algorithm</th><th style="text-align: right">Best For</th></tr><tr><td style="text-align: right"><a href="../api-solver/#PhoXonic.DenseMethod"><code>DenseMethod()</code></a></td><td style="text-align: right">Dense (N×N)</td><td style="text-align: right">LAPACK <code>eigen</code></td><td style="text-align: right">Small/medium systems</td></tr><tr><td style="text-align: right"><a href="../api-solver/#PhoXonic.DenseMethod"><code>DenseMethod(shift=σ)</code></a></td><td style="text-align: right">Dense (N×N)</td><td style="text-align: right">LAPACK <code>eigen</code> + filter</td><td style="text-align: right">3D (skip spurious modes)</td></tr><tr><td style="text-align: right"><a href="../api-solver/#PhoXonic.KrylovKitMethod"><code>KrylovKitMethod()</code></a></td><td style="text-align: right">Matrix-free</td><td style="text-align: right">Arnoldi iteration</td><td style="text-align: right">Large 2D systems</td></tr><tr><td style="text-align: right"><a href="../api-solver/#PhoXonic.KrylovKitMethod"><code>KrylovKitMethod(shift=σ)</code></a></td><td style="text-align: right">Dense + LU</td><td style="text-align: right">Shift-and-invert</td><td style="text-align: right">3D, targeted frequencies</td></tr><tr><td style="text-align: right"><a href="../api-solver/#PhoXonic.LOBPCGMethod"><code>LOBPCGMethod()</code></a></td><td style="text-align: right">Dense (N×N)</td><td style="text-align: right">Block CG</td><td style="text-align: right">Symmetric problems</td></tr><tr><td style="text-align: right"><a href="../api-solver/#PhoXonic.LOBPCGMethod"><code>LOBPCGMethod(shift=σ)</code></a></td><td style="text-align: right">Dense + LU</td><td style="text-align: right">Shift-and-invert LOBPCG</td><td style="text-align: right">3D systems</td></tr></table><h2 id="Memory-and-Computational-Cost"><a class="docs-heading-anchor" href="#Memory-and-Computational-Cost">Memory and Computational Cost</a><a id="Memory-and-Computational-Cost-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-and-Computational-Cost" title="Permalink"></a></h2><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Memory</th><th style="text-align: right">Cost per k-point</th></tr><tr><td style="text-align: right">Dense</td><td style="text-align: right">O(N²)</td><td style="text-align: right">O(N³) eigendecomposition</td></tr><tr><td style="text-align: right">Matrix-free</td><td style="text-align: right">O(N)</td><td style="text-align: right">O(N log N) × iterations</td></tr><tr><td style="text-align: right">Shift-invert</td><td style="text-align: right">O(N²)</td><td style="text-align: right">O(N³) LU + O(N²) × iterations</td></tr><tr><td style="text-align: right">LOBPCG</td><td style="text-align: right">O(N²)</td><td style="text-align: right">O(N² × nev) × iterations</td></tr></table><p><strong>N</strong> = number of plane waves = <code>basis.num_pw</code> × <code>ncomponents(wave)</code></p><p>For large-scale calculations with N &gt; 10,000, see <a href="../matrixfree/#Matrix-Free-Methods">Matrix-Free Methods</a>.</p><h2 id="Recommendations"><a class="docs-heading-anchor" href="#Recommendations">Recommendations</a><a id="Recommendations-1"></a><a class="docs-heading-anchor-permalink" href="#Recommendations" title="Permalink"></a></h2><table><tr><th style="text-align: right">Dimension</th><th style="text-align: right">Wave Type</th><th style="text-align: right">N (typical)</th><th style="text-align: right">Recommended Method</th><th style="text-align: right">Example</th></tr><tr><td style="text-align: right">1D</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.Photonic1D"><code>Photonic1D</code></a></td><td style="text-align: right">&lt; 100</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.DenseMethod"><code>DenseMethod()</code></a></td><td style="text-align: right"><a href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/examples/301_bragg_reflector.jl"><code>301</code></a></td></tr><tr><td style="text-align: right">1D</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.Longitudinal1D"><code>Longitudinal1D</code></a></td><td style="text-align: right">&lt; 100</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.DenseMethod"><code>DenseMethod()</code></a></td><td style="text-align: right"><a href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/examples/302_elastic_superlattice.jl"><code>302</code></a></td></tr><tr><td style="text-align: right">2D</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.TEWave"><code>TEWave</code></a>/<a href="../api-solver/#PhoXonic.TMWave"><code>TMWave</code></a>/<a href="../api-solver/#PhoXonic.SHWave"><code>SHWave</code></a></td><td style="text-align: right">100–1,000</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.DenseMethod"><code>DenseMethod()</code></a></td><td style="text-align: right"><a href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/examples/101_triangular_rods.jl"><code>101</code></a>, <a href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/examples/201_phononic_steel_epoxy.jl"><code>201</code></a></td></tr><tr><td style="text-align: right">2D</td><td style="text-align: right">TE/TM/SH</td><td style="text-align: right">1,000–10,000</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.KrylovKitMethod"><code>KrylovKitMethod()</code></a> or <a href="../api-solver/#PhoXonic.LOBPCGMethod"><code>LOBPCGMethod()</code></a></td><td style="text-align: right"><a href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/examples/201_phononic_steel_epoxy.jl"><code>201</code></a>, <a href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/examples/208_solver_comparison.jl"><code>208</code></a></td></tr><tr><td style="text-align: right">2D</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.PSVWave"><code>PSVWave</code></a></td><td style="text-align: right">200–2,000</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.DenseMethod"><code>DenseMethod()</code></a></td><td style="text-align: right"><a href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/examples/201_phononic_steel_epoxy.jl"><code>201</code></a></td></tr><tr><td style="text-align: right">2D</td><td style="text-align: right">PSVWave</td><td style="text-align: right">&gt; 2,000</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.KrylovKitMethod"><code>KrylovKitMethod()</code></a> or <a href="../api-solver/#PhoXonic.LOBPCGMethod"><code>LOBPCGMethod()</code></a></td><td style="text-align: right"><a href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/examples/201_phononic_steel_epoxy.jl"><code>201</code></a>, <a href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/examples/208_solver_comparison.jl"><code>208</code></a></td></tr><tr><td style="text-align: right">3D</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.TransverseEM"><code>TransverseEM</code></a></td><td style="text-align: right">&lt; 2,000</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.DenseMethod"><code>DenseMethod()</code></a> <strong>(recommended)</strong></td><td style="text-align: right"><a href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/examples/401_fcc_spheres.jl"><code>401</code></a></td></tr><tr><td style="text-align: right">3D</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.FullVectorEM"><code>FullVectorEM</code></a></td><td style="text-align: right">&lt; 500</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.DenseMethod"><code>DenseMethod(shift=0.01)</code></a></td><td style="text-align: right"><a href="https://github.com/hsugawa8651/PhoXonic.jl/blob/main/examples/402_sc_spheres.jl"><code>402</code></a></td></tr><tr><td style="text-align: right">3D</td><td style="text-align: right">FullVectorEM</td><td style="text-align: right">500–5,000</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.KrylovKitMethod"><code>KrylovKitMethod(shift=0.01)</code></a> or <a href="../api-solver/#PhoXonic.LOBPCGMethod"><code>LOBPCGMethod(shift=0.01)</code></a></td><td style="text-align: right">—</td></tr><tr><td style="text-align: right">3D</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.FullElastic"><code>FullElastic</code></a></td><td style="text-align: right">&lt; 500</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.DenseMethod"><code>DenseMethod(shift=0.01)</code></a></td><td style="text-align: right">—</td></tr><tr><td style="text-align: right">3D</td><td style="text-align: right">FullElastic</td><td style="text-align: right">500–5,000</td><td style="text-align: right"><a href="../api-solver/#PhoXonic.KrylovKitMethod"><code>KrylovKitMethod(shift=0.01)</code></a> or <a href="../api-solver/#PhoXonic.LOBPCGMethod"><code>LOBPCGMethod(shift=0.01)</code></a></td><td style="text-align: right">—</td></tr></table><p><strong>Note:</strong> For 3D photonic crystals, <code>TransverseEM</code> is strongly recommended over <code>FullVectorEM</code>. See <a href="../workflow_3d/#TransverseEM-vs-FullVectorEM">TransverseEM vs FullVectorEM</a> for why.</p><p><strong>Note:</strong> For 3D phononic crystals, <code>FullElastic</code> is an experimental implementation. See <a href="../workflow_3d/#FullElastic-(Experimental)">FullElastic (Experimental)</a> for why parameter tuning is challenging.</p><h2 id="DenseMethod"><a class="docs-heading-anchor" href="#DenseMethod">DenseMethod</a><a id="DenseMethod-1"></a><a class="docs-heading-anchor-permalink" href="#DenseMethod" title="Permalink"></a></h2><p>The default solver using LAPACK&#39;s dense eigenvalue decomposition.</p><h3 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h3><pre><code class="language-julia hljs">solver = Solver(TEWave(), geo, (64, 64), DenseMethod(); cutoff=7)</code></pre><h3 id="DenseMethod-for-3D"><a class="docs-heading-anchor" href="#DenseMethod-for-3D">DenseMethod for 3D</a><a id="DenseMethod-for-3D-1"></a><a class="docs-heading-anchor-permalink" href="#DenseMethod-for-3D" title="Permalink"></a></h3><p>For small 3D systems, <code>DenseMethod</code> with <code>shift &gt; 0</code> can be used:</p><pre><code class="language-julia hljs">solver = Solver(FullVectorEM(), geo, (12, 12, 12), DenseMethod(shift=0.01); cutoff=5)  # Use cutoff≥7 for high ε</code></pre><p><strong>How it works:</strong></p><p>Unlike iterative methods which use shift-and-invert transformation, <code>DenseMethod(shift=σ)</code> computes <strong>all</strong> eigenvalues using LAPACK, then filters out eigenvalues where ω² &lt; σ. This post-hoc filtering effectively removes the spurious longitudinal modes at ω ≈ 0.</p><p><strong>Important difference from iterative methods:</strong></p><table><tr><th style="text-align: right">Aspect</th><th style="text-align: right">DenseMethod</th><th style="text-align: right">KrylovKitMethod/LOBPCGMethod</th></tr><tr><td style="text-align: right">Computation</td><td style="text-align: right">All eigenvalues</td><td style="text-align: right">Only requested number</td></tr><tr><td style="text-align: right">Filtering</td><td style="text-align: right">Post-hoc (ω² &lt; σ removed)</td><td style="text-align: right">Shift-and-invert (finds λ closest to σ)</td></tr><tr><td style="text-align: right">Band ordering</td><td style="text-align: right">Strictly ascending ω</td><td style="text-align: right">Depends on σ proximity</td></tr><tr><td style="text-align: right">Memory</td><td style="text-align: right">O(N²)</td><td style="text-align: right">O(N²) with shift, O(N) without</td></tr></table><p>This means Dense and iterative methods may return <strong>different bands</strong> for the same <code>bands=1:n</code> request if there are intermediate eigenvalues. Both results are valid eigenvalues, just in different order.</p><p><strong>When to use DenseMethod for 3D:</strong></p><ul><li>Small systems (N × 3 &lt; 2000)</li><li>Validation and debugging</li><li>Need all eigenvalues in ascending order</li></ul><h2 id="KrylovKitMethod"><a class="docs-heading-anchor" href="#KrylovKitMethod">KrylovKitMethod</a><a id="KrylovKitMethod-1"></a><a class="docs-heading-anchor-permalink" href="#KrylovKitMethod" title="Permalink"></a></h2><p>Iterative solver based on KrylovKit.jl using Arnoldi iteration.</p><h3 id="Basic-Usage-2"><a class="docs-heading-anchor" href="#Basic-Usage-2">Basic Usage</a><a class="docs-heading-anchor-permalink" href="#Basic-Usage-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">solver = Solver(TEWave(), geo, (128, 128), KrylovKitMethod(); cutoff=15)</code></pre><h3 id="Shift-and-Invert-for-3D"><a class="docs-heading-anchor" href="#Shift-and-Invert-for-3D">Shift-and-Invert for 3D</a><a id="Shift-and-Invert-for-3D-1"></a><a class="docs-heading-anchor-permalink" href="#Shift-and-Invert-for-3D" title="Permalink"></a></h3><p>For 3D calculations, use shift-and-invert to skip longitudinal modes:</p><pre><code class="language-julia hljs">solver = Solver(FullVectorEM(), geo, (16, 16, 16), KrylovKitMethod(shift=0.01); cutoff=7)</code></pre><p>The shift parameter σ transforms the generalized eigenvalue problem:</p><table><tr><th style="text-align: right">Original</th><th style="text-align: right">Transformed</th></tr><tr><td style="text-align: right">A x = λ B x</td><td style="text-align: right">(A - σB)⁻¹ B x = μ x</td></tr><tr><td style="text-align: right">λ = eigenvalue</td><td style="text-align: right">μ = 1/(λ - σ)</td></tr></table><p>Eigenvalues closest to σ become the largest |μ|, making them easiest for iterative solvers to find.</p><h3 id="Why-is-Shift-Needed-for-3D?"><a class="docs-heading-anchor" href="#Why-is-Shift-Needed-for-3D?">Why is Shift Needed for 3D?</a><a id="Why-is-Shift-Needed-for-3D?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-is-Shift-Needed-for-3D?" title="Permalink"></a></h3><p>The 3D H-field formulation does not explicitly enforce ∇·H = 0, producing:</p><ul><li><strong>Longitudinal modes</strong>: λ ≈ 0 (unphysical, violate transversality)</li><li><strong>Transverse modes</strong>: λ &gt; 0 (physical electromagnetic waves)</li></ul><p>Without shift, iterative solvers converge to the spurious λ ≈ 0 modes first. With shift σ &gt; 0, eigenvalues λ &lt; σ are effectively filtered out.</p><h3 id="Choosing-σ"><a class="docs-heading-anchor" href="#Choosing-σ">Choosing σ</a><a id="Choosing-σ-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-σ" title="Permalink"></a></h3><table><tr><th style="text-align: right">Use case</th><th style="text-align: right">Recommended σ</th><th style="text-align: right">Explanation</th></tr><tr><td style="text-align: right">Skip longitudinal modes</td><td style="text-align: right">0.001 – 0.1</td><td style="text-align: right">Must be &gt; 0, but smaller than the smallest physical λ</td></tr><tr><td style="text-align: right">Target specific frequency</td><td style="text-align: right">ω²_target</td><td style="text-align: right">Finds modes near the target frequency first</td></tr><tr><td style="text-align: right">Low-frequency modes near k</td><td style="text-align: right">|k|²/ε_max</td><td style="text-align: right">Approximate lowest transverse eigenvalue</td></tr></table><p><strong>Guidelines for choosing σ:</strong></p><ol><li><p><strong>Lower bound</strong>: σ must be larger than the longitudinal mode eigenvalues (≈ 0). A small positive value like <code>σ = 0.01</code> typically works.</p></li><li><p><strong>Upper bound</strong>: σ should be smaller than the smallest physical eigenvalue you want to find. For a homogeneous medium: λ<em>min ≈ |k|²/ε</em>max.</p><p>Example: |k| = 0.5, ε = 4 → λ_min ≈ 0.0625. Use σ &lt; 0.06.</p></li><li><p><strong>Safe default</strong>: For most 3D photonic calculations, <code>σ = 0.01</code> works well when |k| ≥ 0.1 (in units of 2π/a).</p></li><li><p><strong>Near k = 0</strong>: At the Γ point (k = 0), the lowest transverse modes also have λ → 0. Use a very small shift (σ ~ 0.001) or skip the Γ point.</p></li><li><p><strong>High-contrast materials</strong>: For large ε, eigenvalues scale as 1/ε. Reduce σ proportionally: <code>σ ≈ 0.01 / ε_max</code>.</p></li></ol><h3 id="Troubleshooting"><a class="docs-heading-anchor" href="#Troubleshooting">Troubleshooting</a><a id="Troubleshooting-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting" title="Permalink"></a></h3><table><tr><th style="text-align: right">Symptom</th><th style="text-align: right">Likely cause</th><th style="text-align: right">Solution</th></tr><tr><td style="text-align: right">All eigenvalues ≈ 0</td><td style="text-align: right">σ too large</td><td style="text-align: right">Reduce σ</td></tr><tr><td style="text-align: right">Missing low-frequency modes</td><td style="text-align: right">σ too large</td><td style="text-align: right">Reduce σ below λ_min</td></tr><tr><td style="text-align: right">Converges to spurious modes</td><td style="text-align: right">σ too small or = 0</td><td style="text-align: right">Increase σ &gt; 0</td></tr><tr><td style="text-align: right">Slow convergence</td><td style="text-align: right">σ far from target λ</td><td style="text-align: right">Adjust σ closer to desired eigenvalues</td></tr></table><h3 id="Phononic-Eigenvalue-Scaling"><a class="docs-heading-anchor" href="#Phononic-Eigenvalue-Scaling">Phononic Eigenvalue Scaling</a><a id="Phononic-Eigenvalue-Scaling-1"></a><a class="docs-heading-anchor-permalink" href="#Phononic-Eigenvalue-Scaling" title="Permalink"></a></h3><p>Phononic eigenvalues ω² are typically O(10¹⁰) for common materials (steel, epoxy, etc.), which can cause numerical instability in iterative solvers. PhoXonic.jl automatically scales the eigenvalue problem for <code>SHWave</code>, <code>PSVWave</code>, <code>FullElastic</code>, and <code>Longitudinal1D</code>:</p><pre><code class="nohighlight hljs">Scaled problem: (A/s) x = (λ/s) B x
where s = c² × |k|² and c² = C₁₁/ρ (longitudinal wave speed squared)</code></pre><p>This normalizes eigenvalues to O(1), ensuring stable convergence. The scaling is:</p><ul><li><strong>Automatic</strong>: No user configuration needed</li><li><strong>Transparent</strong>: Results are unscaled before return</li><li><strong>Photonic-safe</strong>: Scale factor = 1.0 for TE/TM/FullVectorEM</li></ul><p><strong>Example:</strong> Steel/epoxy at |k| = 100 rad/m:</p><ul><li>Without scaling: ω² ~ 10¹⁰ → KrylovKit may fail</li><li>With scaling: ω²/s ~ 1 → stable convergence</li></ul><h3 id="KrylovKitMethod-Parameters"><a class="docs-heading-anchor" href="#KrylovKitMethod-Parameters">KrylovKitMethod Parameters</a><a id="KrylovKitMethod-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#KrylovKitMethod-Parameters" title="Permalink"></a></h3><pre><code class="language-julia hljs">method = KrylovKitMethod(
    tol = 1e-8,       # Convergence tolerance
    maxiter = 300,    # Maximum iterations
    krylovdim = 30,   # Krylov subspace dimension
    verbosity = 0,    # 0=silent, 1=warnings, 2=info
    shift = 0.0,      # Spectral shift (0 = no shift)
    matrix_free = false  # Use matrix-free operators for shift-and-invert
)</code></pre><h3 id="Matrix-Free-Shift-and-Invert"><a class="docs-heading-anchor" href="#Matrix-Free-Shift-and-Invert">Matrix-Free Shift-and-Invert</a><a id="Matrix-Free-Shift-and-Invert-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Free-Shift-and-Invert" title="Permalink"></a></h3><p>For large 3D calculations where memory is limited, the <code>matrix_free=true</code> option avoids building dense matrices:</p><pre><code class="language-julia hljs"># Memory-efficient for large 3D systems
solver = Solver(
    FullVectorEM(), geo, (32, 32, 32),
    KrylovKitMethod(shift=0.01, matrix_free=true);
    cutoff=5
)</code></pre><p><strong>Comparison:</strong></p><table><tr><th style="text-align: right">Aspect</th><th style="text-align: right"><code>matrix_free=false</code> (default)</th><th style="text-align: right"><code>matrix_free=true</code></th></tr><tr><td style="text-align: right">Memory</td><td style="text-align: right">O(N²)</td><td style="text-align: right">O(N)</td></tr><tr><td style="text-align: right">Speed</td><td style="text-align: right">Faster for N &lt; 2000</td><td style="text-align: right">Slower (nested iteration)</td></tr><tr><td style="text-align: right">Best for</td><td style="text-align: right">Small/medium 3D</td><td style="text-align: right">Large 3D (N &gt; 2000)</td></tr></table><p><strong>How it works:</strong></p><ul><li>Default mode: Builds dense matrices LHS, RHS, computes LU factorization of (A - σB)</li><li>Matrix-free mode: Uses FFT-based operators and iterative CG solver for inner system</li></ul><p>For most 3D calculations with <code>cutoff ≤ 5</code>, the default dense mode is faster. Use <code>matrix_free=true</code> when memory becomes the limiting factor.</p><h2 id="LOBPCGMethod"><a class="docs-heading-anchor" href="#LOBPCGMethod">LOBPCGMethod</a><a id="LOBPCGMethod-1"></a><a class="docs-heading-anchor-permalink" href="#LOBPCGMethod" title="Permalink"></a></h2><p>LOBPCG (Locally Optimal Block Preconditioned Conjugate Gradient) is an iterative eigenvalue solver. A. V. Knyazev, SIAM J. Sci. Comput. 23, 517 (2001). <a href="https://doi.org/10.1137/S1064827500366124">DOI:10.1137/S1064827500366124</a></p><h3 id="When-to-Use-LOBPCG"><a class="docs-heading-anchor" href="#When-to-Use-LOBPCG">When to Use LOBPCG</a><a id="When-to-Use-LOBPCG-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-LOBPCG" title="Permalink"></a></h3><p>LOBPCG is effective for:</p><ul><li>Large-scale band structure calculations (cutoff ≥ 12)</li><li>Symmetric generalized eigenvalue problems A x = λ B x</li><li>Computing multiple eigenvalues simultaneously (block method)</li></ul><p><strong>Performance comparison (2D PSV wave, Steel/Epoxy):</strong></p><table><tr><th style="text-align: right">Cutoff</th><th style="text-align: right">Matrix Size</th><th style="text-align: right">Dense</th><th style="text-align: right">LOBPCG</th><th style="text-align: right">Speedup</th><th style="text-align: right">Error</th></tr><tr><td style="text-align: right">8</td><td style="text-align: right">394</td><td style="text-align: right">4.4 s</td><td style="text-align: right">11.8 s</td><td style="text-align: right">0.37x*</td><td style="text-align: right">8.5 rad/s</td></tr><tr><td style="text-align: right">10</td><td style="text-align: right">634</td><td style="text-align: right">10.1 s</td><td style="text-align: right">12.8 s</td><td style="text-align: right">0.79x*</td><td style="text-align: right">16.2 rad/s</td></tr><tr><td style="text-align: right">12</td><td style="text-align: right">882</td><td style="text-align: right">21.5 s</td><td style="text-align: right">19.8 s</td><td style="text-align: right"><strong>1.09x</strong></td><td style="text-align: right">15.8 rad/s</td></tr><tr><td style="text-align: right">15</td><td style="text-align: right">1418</td><td style="text-align: right">105.3 s</td><td style="text-align: right">50.4 s</td><td style="text-align: right"><strong>2.09x</strong></td><td style="text-align: right">30.2 rad/s</td></tr></table><p>*Speedup &lt; 1 means Dense is faster</p><p><strong>Recommendation:</strong></p><ul><li>cutoff &lt; 10: Use Dense (faster due to BLAS optimization)</li><li>cutoff ≥ 12: Use LOBPCG (speedup increases with problem size)</li></ul><h3 id="Basic-Usage-3"><a class="docs-heading-anchor" href="#Basic-Usage-3">Basic Usage</a><a class="docs-heading-anchor-permalink" href="#Basic-Usage-3" title="Permalink"></a></h3><pre><code class="language-julia hljs"># 2D photonic
solver = Solver(TEWave(), geo, (64, 64), LOBPCGMethod(); cutoff=12)

# 2D phononic (LOBPCG effective for large problems)
solver = Solver(PSVWave(), geo, (64, 64), LOBPCGMethod(); cutoff=15)</code></pre><h3 id="Shift-and-Invert-for-3D-2"><a class="docs-heading-anchor" href="#Shift-and-Invert-for-3D-2">Shift-and-Invert for 3D</a><a class="docs-heading-anchor-permalink" href="#Shift-and-Invert-for-3D-2" title="Permalink"></a></h3><p>For 3D calculations, LOBPCG requires <code>shift &gt; 0</code> to skip spurious longitudinal modes:</p><pre><code class="language-julia hljs">solver = Solver(FullVectorEM(), geo, (16, 16, 16), LOBPCGMethod(shift=0.01); cutoff=7)

solver = Solver(FullElastic(), geo, (16, 16, 16), LOBPCGMethod(shift=0.01); cutoff=5)</code></pre><p><strong>Why is shift needed for 3D?</strong></p><p>The 3D H-field formulation does not enforce the transversality constraint ∇·H = 0, leading to spurious longitudinal modes at λ ≈ 0. Without shift:</p><ul><li>LOBPCG tries to find smallest eigenvalues, converging to these spurious modes</li><li>The RHS matrix B becomes singular in this subspace → <code>PosDefException</code></li></ul><p>With <code>shift=σ</code>, the problem transforms to <code>(A - σB)⁻¹ B x = μ x</code>, which only returns eigenvalues λ &gt; σ, effectively filtering out the spurious modes.</p><h3 id="LOBPCGMethod-Parameters"><a class="docs-heading-anchor" href="#LOBPCGMethod-Parameters">LOBPCGMethod Parameters</a><a id="LOBPCGMethod-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#LOBPCGMethod-Parameters" title="Permalink"></a></h3><pre><code class="language-julia hljs">method = LOBPCGMethod(
    tol = 1e-3,              # Convergence tolerance (default)
    maxiter = 100,           # Maximum iterations (default)
    shift = 0.0,             # Spectral shift (required for 3D)
    warm_start = true,       # Use previous eigenvectors as initial guess
    first_dense = true,      # Solve first k-point with Dense
)</code></pre><h3 id="Warm-Start-for-Band-Structure-Calculations"><a class="docs-heading-anchor" href="#Warm-Start-for-Band-Structure-Calculations">Warm Start for Band Structure Calculations</a><a id="Warm-Start-for-Band-Structure-Calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Warm-Start-for-Band-Structure-Calculations" title="Permalink"></a></h3><p>When computing band structures with <code>compute_bands</code>, LOBPCG uses <strong>warm start</strong> to speed up calculations. The eigenvectors from the previous k-point serve as the initial guess for the next k-point.</p><p><strong>How it works:</strong></p><ol><li>First k-point is solved with <code>DenseMethod</code> (when <code>first_dense=true</code>)</li><li>Subsequent k-points use previous eigenvectors as initial guess</li><li>Since eigenvectors vary smoothly along k-path, LOBPCG converges quickly</li></ol><p><strong>Usage:</strong></p><pre><code class="language-julia hljs"># Automatic warm start (default)
solver = Solver(PSVWave(), geo, (64, 64), LOBPCGMethod(); cutoff=15)
bands = compute_bands(solver, kpath; bands=1:10)</code></pre><h3 id="Limitations"><a class="docs-heading-anchor" href="#Limitations">Limitations</a><a id="Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations" title="Permalink"></a></h3><ul><li>For small problems (cutoff &lt; 10), Dense is faster due to BLAS optimization</li><li>Phononic problems with band crossings at Γ point may require additional care</li><li>Accuracy is typically 10-100 rad/s compared to Dense (0.1-1% relative error)</li></ul><h3 id="LOBPCG-vs-KrylovKit"><a class="docs-heading-anchor" href="#LOBPCG-vs-KrylovKit">LOBPCG vs KrylovKit</a><a id="LOBPCG-vs-KrylovKit-1"></a><a class="docs-heading-anchor-permalink" href="#LOBPCG-vs-KrylovKit" title="Permalink"></a></h3><table><tr><th style="text-align: right">Feature</th><th style="text-align: right"><a href="../api-solver/#PhoXonic.KrylovKitMethod">KrylovKitMethod</a></th><th style="text-align: right"><a href="../api-solver/#PhoXonic.LOBPCGMethod">LOBPCGMethod</a></th></tr><tr><td style="text-align: right">Backend</td><td style="text-align: right"><a href="https://jutho.github.io/KrylovKit.jl/stable/">KrylovKit.jl</a></td><td style="text-align: right"><a href="https://iterativesolvers.julialinearalgebra.org/stable/">IterativeSolvers.jl</a></td></tr><tr><td style="text-align: right">Algorithm</td><td style="text-align: right">Arnoldi (Krylov)</td><td style="text-align: right">Block CG</td></tr><tr><td style="text-align: right">Matrix-free</td><td style="text-align: right">Yes (2D/3D)</td><td style="text-align: right">No</td></tr><tr><td style="text-align: right">Phononic scaling</td><td style="text-align: right">Required</td><td style="text-align: right">Not required</td></tr><tr><td style="text-align: right">Block computation</td><td style="text-align: right">No</td><td style="text-align: right">Yes</td></tr><tr><td style="text-align: right">3D shift-invert</td><td style="text-align: right">Yes</td><td style="text-align: right">Yes</td></tr></table><p>For details on matrix-free methods and their resolution constraints, see <a href="../matrixfree/#Matrix-Free-Methods">Matrix-Free Methods</a>.</p><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><ul><li><a href="../api-solver/">Solver API</a> - DenseMethod, KrylovKitMethod, LOBPCGMethod</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../workflow_3d/">« 3D Calculations</a><a class="docs-footer-nextpage" href="../analysis/">Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 18 February 2026 07:14">Wednesday 18 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
